--- netwerk/protocol/http/nsHttpChannel.cpp
+++ netwerk/protocol/http/nsHttpChannel.cpp
@@ -4593,32 +4593,16 @@
 
     nsresult rv = CreateNewURI(location, getter_AddRefs(mRedirectURI));
 
     if (NS_FAILED(rv)) {
         LOG(("Invalid URI for redirect: Location: %s\n", location));
         return NS_ERROR_CORRUPTED_CONTENT;
     }
 
-    nsAutoCString redirectHost;
-    mRedirectURI->GetHost(redirectHost);
-    nsAutoCString currentHost;
-    mURI->GetHost(currentHost);
-    if (redirectHost != currentHost) {
-        // When redirecting to another domain, the target domain should not be
-        // percent encoded, as the URL parser does not yet support that
-        nsAutoCString unescapedHost;
-        if (NS_UnescapeURL(redirectHost.BeginReading(), redirectHost.Length(),
-                           0, unescapedHost)) {
-            if (IsUTF8(unescapedHost)) {
-                mRedirectURI->SetHost(unescapedHost);
-            }
-        }
-    }
-
     if (mApplicationCache) {
         // if we are redirected to a different origin check if there is a fallback
         // cache entry to fall back to. we don't care about file strict
         // checking, at least mURI is not a file URI.
         if (!NS_SecurityCompareURIs(mURI, mRedirectURI, false)) {
             PushRedirectAsyncFunc(&nsHttpChannel::ContinueProcessRedirectionAfterFallback);
             bool waitingForRedirectCallback;
             (void)ProcessFallback(&waitingForRedirectCallback);
