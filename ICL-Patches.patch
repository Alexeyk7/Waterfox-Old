From 416b4b7ef7f992897041d0781569be14387d4d39 Mon Sep 17 00:00:00 2001
From: Alex Kontos <alex@waterfoxproject.org>
Date: Mon, 30 Nov 2015 02:02:48 +0000
Subject: [PATCH] ICL Patches

---
 config/config.mk                                   |    2 +-
 configure.in                                       |    8 +-
 image/RasterImage.cpp                              |   72 +-
 image/SurfaceCache.cpp                             |   10 +-
 js/public/TraceKind.h                              |    8 +-
 js/src/configure.in                                |    2 +-
 js/src/jscompartment.cpp                           |    2 +-
 js/src/jsgc.cpp                                    |    2 +-
 js/src/jsobj.cpp                                   |    4 +-
 js/src/vm/Debugger.cpp                             |    8 +-
 js/src/vm/Debugger.h                               |    6 +-
 js/src/vm/TaggedProto.cpp                          |   37 +-
 media/mtransport/runnable_utils.h                  |   27 +-
 mfbt/Atomics.h                                     |  426 ++++-
 mfbt/CheckedInt.h                                  |    2 +-
 nsprpub/config/rules.mk                            |   15 +-
 nsprpub/configure                                  |    4 +-
 nsprpub/configure.in                               |    3 -
 .../chromium/sandbox/win/src/sandbox_nt_util.cc    |    4 +-
 xpcom/threads/MozPromise.h                         |    9 +-

diff --git a/config/config.mk b/config/config.mk
index b9bc3ae..63ce47f 100755
--- a/config/config.mk
+++ b/config/config.mk
@@ -478,7 +478,7 @@ endif # WINNT
 ifdef _MSC_VER
 ifeq ($(CPU_ARCH),x86_64)
 # set stack to 2MB on x64 build.  See bug 582910
-WIN32_EXE_LDFLAGS	+= -STACK:2097152
+WIN32_EXE_LDFLAGS	+= -STACK:2097152 -FORCE
 endif
 endif
 
diff --git a/configure.in b/configure.in
index 0b520ea..1454a13 100755
--- a/configure.in
+++ b/configure.in
@@ -608,13 +608,9 @@ See https://developer.mozilla.org/en/Windows_Build_Prerequisites.])
         AC_SUBST(MSVC_DESKTOPCRT_DLL)
 
         # Disable SEH on clang-cl because it doesn't implement them yet.
-        if test -z "$CLANG_CL"; then
-            AC_DEFINE(HAVE_SEH_EXCEPTIONS)
-        else
             # Send our CFLAGS to NSS
             MOZ_CFLAGS_NSS=1
             AC_DEFINE_UNQUOTED(GTEST_HAS_SEH, 0)
-        fi
 
         if test -n "$WIN32_REDIST_DIR"; then
           if test ! -d "$WIN32_REDIST_DIR"; then
@@ -1750,7 +1746,7 @@ fi
 dnl ========================================================
 dnl SPS Profiler
 dnl ========================================================
-MOZ_ENABLE_PROFILER_SPS=1
+MOZ_ENABLE_PROFILER_SPS=
 
 case "${OS_TARGET}" in
 Android)
@@ -2258,7 +2254,7 @@ ia64*-hpux*)
         CFLAGS="$CFLAGS -we4553"
         CXXFLAGS="$CXXFLAGS -we4553"
         LIBS="$LIBS kernel32.lib user32.lib gdi32.lib winmm.lib wsock32.lib advapi32.lib secur32.lib netapi32.lib"
-        MOZ_DEBUG_LDFLAGS='-DEBUG -DEBUGTYPE:CV'
+        MOZ_DEBUG_LDFLAGS='-DEBUG'
         WARNINGS_AS_ERRORS='-WX'
         MOZ_OPTIMIZE_FLAGS='-O1 -Oi'
         MOZ_FIX_LINK_PATHS=
diff --git a/image/RasterImage.cpp b/image/RasterImage.cpp
index 69d3aea..17b56eb 100644
--- a/image/RasterImage.cpp
+++ b/image/RasterImage.cpp
@@ -42,7 +42,8 @@
 #include <stdint.h>
 #include "mozilla/Telemetry.h"
 #include "mozilla/TimeStamp.h"
-#include "mozilla/Tuple.h"
+//#include "mozilla/Tuple.h"
+#include <tuple>
 #include "mozilla/ClearOnShutdown.h"
 #include "mozilla/gfx/Scale.h"
 
@@ -622,20 +623,24 @@ RasterImage::GetCurrentImage(ImageContainer* aContainer, uint32_t aFlags)
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aContainer);
 
-  DrawResult drawResult;
-  RefPtr<SourceSurface> surface;
-  Tie(drawResult, surface) =
-    GetFrameInternal(mSize, FRAME_CURRENT, aFlags | FLAG_ASYNC_NOTIFY);
-  if (!surface) {
+	auto result = GetFrameInternal(FRAME_CURRENT, aFlags | FLAG_ASYNC_NOTIFY);
+	if (!result.second()) {
+//  DrawResult drawResult;
+//  RefPtr<SourceSurface> surface;
+//  std::tie(drawResult, surface) =
+//	  GetFrameInternal(mSize, FRAME_CURRENT, aFlags | FLAG_ASYNC_NOTIFY);
+//  if (!surface) {
     // The OS threw out some or all of our buffer. We'll need to wait for the
     // redecode (which was automatically triggered by GetFrame) to complete.
-    return MakePair(drawResult, nsRefPtr<layers::Image>());
+//    return MakePair(drawResult, nsRefPtr<layers::Image>());
+	return MakePair(result.first(), nsRefPtr<layers::Image>());
   }
 
   CairoImage::Data cairoData;
   GetWidth(&cairoData.mSize.width);
   GetHeight(&cairoData.mSize.height);
-  cairoData.mSourceSurface = surface;
+  //cairoData.mSourceSurface = surface;
+  cairoData.mSourceSurface = result.second();
 
   nsRefPtr<layers::Image> image =
     aContainer->CreateImage(ImageFormat::CAIRO_SURFACE);
@@ -643,7 +648,8 @@ RasterImage::GetCurrentImage(ImageContainer* aContainer, uint32_t aFlags)
 
   static_cast<CairoImage*>(image.get())->SetData(cairoData);
 
-  return MakePair(drawResult, Move(image));
+  //return MakePair(drawResult, Move(image));
+  return MakePair(result.first(), Move(image));
 }
 
 NS_IMETHODIMP_(bool)
@@ -695,19 +701,27 @@ RasterImage::GetImageContainer(LayerManager* aManager, uint32_t aFlags)
   // We need a new ImageContainer, so create one.
   container = LayerManager::CreateImageContainer();
 
-  DrawResult drawResult;
-  nsRefPtr<layers::Image> image;
-  Tie(drawResult, image) = GetCurrentImage(container, aFlags);
-  if (!image) {
+	auto result = GetCurrentImage(container, aFlags);
+	if (!result.second()) {
+	// We couldn't get an Image.
+//  DrawResult drawResult;
+//  nsRefPtr<layers::Image> image;
+//  std::tie(drawResult, image) = GetCurrentImage(container, aFlags);
+//  if (!image) {
     return nullptr;
   }
 
-  // |image| holds a reference to a SourceSurface which in turn holds a lock on
-  // the current frame's VolatileBuffer, ensuring that it doesn't get freed as
-  // long as the layer system keeps this ImageContainer alive.
-  container->SetCurrentImageInTransaction(image);
+	// |result.second()| holds a reference to a SourceSurface which in turn holds
+	// a lock on the current frame's VolatileBuffer, ensuring that it doesn't get
+	// freed as long as the layer system keeps this ImageContainer alive.
+	container->SetCurrentImageInTransaction(result.second());
+   // |image| holds a reference to a SourceSurface which in turn holds a lock on
+   // the current frame's VolatileBuffer, ensuring that it doesn't get freed as
+   // long as the layer system keeps this ImageContainer alive.
+//  container->SetCurrentImageInTransaction(image);
 
-  mLastImageContainerDrawResult = drawResult;
+	mLastImageContainerDrawResult = result.first();
+//  mLastImageContainerDrawResult = drawResult;
   mImageContainer = container;
 
   return container.forget();
@@ -723,17 +737,23 @@ RasterImage::UpdateImageContainer()
     return;
   }
 
-  DrawResult drawResult;
-  nsRefPtr<layers::Image> image;
-  Tie(drawResult, image) = GetCurrentImage(container, FLAG_NONE);
-  if (!image) {
+	auto result = GetCurrentImage(container, FLAG_NONE);
+	if (!result.second()) {
+	// We couldn't get an Image.
+//  DrawResult drawResult;
+//  nsRefPtr<layers::Image> image;
+//  std::tie(drawResult, image) = GetCurrentImage(container, FLAG_NONE);
+//  if (!image) {
     return;
   }
 
-  mLastImageContainerDrawResult = drawResult;
-  nsAutoTArray<ImageContainer::NonOwningImage, 1> imageList;
-  imageList.AppendElement(ImageContainer::NonOwningImage(image));
-  container->SetCurrentImages(imageList);
+	mLastImageContainerDrawResult = result.first();
+	nsAutoTArray<ImageContainer::NonOwningImage, 1> imageList;
+	imageList.AppendElement(
+	ImageContainer::NonOwningImage(result.second()));
+//  mLastImageContainerDrawResult = drawResult;
+//  nsAutoTArray<ImageContainer::NonOwningImage, 1> imageList;
+//  imageList.AppendElement(ImageContainer::NonOwningImage(image));
 }
 
 size_t
diff --git a/image/SurfaceCache.cpp b/image/SurfaceCache.cpp
index 6ffc76b..e59f16e 100644
--- a/image/SurfaceCache.cpp
+++ b/image/SurfaceCache.cpp
@@ -19,7 +19,8 @@
 #include "mozilla/Pair.h"
 #include "mozilla/RefPtr.h"
 #include "mozilla/StaticPtr.h"
-#include "mozilla/Tuple.h"
+//#include "mozilla/Tuple.h"
+#include <tuple>
 #include "nsIMemoryReporter.h"
 #include "gfx2DGlue.h"
 #include "gfxPattern.h"  // Workaround for flaw in bug 921753 part 2.
@@ -655,9 +656,12 @@ public:
     DrawableFrameRef ref;
     MatchType matchType = MatchType::NOT_FOUND;
     while (true) {
-      Tie(surface, matchType) =
+		// XXX(seth): This code is begging for std::tie. See bug 1184385.
+		Pair<already_AddRefed<CachedSurface>, MatchType> lookupResult =
+//      std::tie(surface, matchType) =
         cache->LookupBestMatch(aSurfaceKey, aAlternateFlags);
-
+		surface = lookupResult.first();
+		matchType = lookupResult.second();
       if (!surface) {
         return LookupResult(matchType);  // Lookup in the per-image cache missed.
       }
diff --git a/js/public/TraceKind.h b/js/public/TraceKind.h
index f4db1e2..8ba6d78 100644
--- a/js/public/TraceKind.h
+++ b/js/public/TraceKind.h
@@ -100,11 +100,11 @@ JS_FOR_EACH_TRACEKIND(JS_EXPAND_DEF);
 // the other hand, gets very confused if we have a |template| token there.
 // The clang-cl front end defines _MSC_VER, but still requires the explicit
 // template declaration, so we must test for __clang__ here as well.
-#if defined(_MSC_VER) && !defined(__clang__)
-# define JS_DEPENDENT_TEMPLATE_HINT
-#else
+// #if defined(_MSC_VER) && (!defined(__clang__) || !defined(__ICL))
+// # define JS_DEPENDENT_TEMPLATE_HINT
+// #else
 # define JS_DEPENDENT_TEMPLATE_HINT template
-#endif
+// #endif
 template <typename F, typename... Args>
 auto
 DispatchTraceKindTyped(F f, JS::TraceKind traceKind, Args&&... args)
diff --git a/js/src/configure.in b/js/src/configure.in
index 469609f..5e97402 100755
--- a/js/src/configure.in
+++ b/js/src/configure.in
@@ -1770,7 +1770,7 @@ ia64*-hpux*)
         CFLAGS="$CFLAGS -we4553"
         CXXFLAGS="$CXXFLAGS -we4553"
         LIBS="$LIBS kernel32.lib user32.lib gdi32.lib winmm.lib wsock32.lib advapi32.lib psapi.lib"
-        MOZ_DEBUG_LDFLAGS='-DEBUG -DEBUGTYPE:CV'
+        MOZ_DEBUG_LDFLAGS='-DEBUG'
         WARNINGS_AS_ERRORS='-WX'
         MOZ_OPTIMIZE_FLAGS="-O2"
         MOZ_FIX_LINK_PATHS=
diff --git a/js/src/jscompartment.cpp b/js/src/jscompartment.cpp
index fe485dc..f5c6977 100755
--- a/js/src/jscompartment.cpp
+++ b/js/src/jscompartment.cpp
@@ -517,7 +517,7 @@ JSCompartment::traceIncomingCrossCompartmentEdgesForZoneGC(JSTracer* trc)
         if (!c->zone()->isCollecting())
             c->traceOutgoingCrossCompartmentWrappers(trc);
     }
-    Debugger::markIncomingCrossCompartmentEdges(trc);
+    //Debugger::markIncomingCrossCompartmentEdges(trc);
 }
 
 void
diff --git a/js/src/jsgc.cpp b/js/src/jsgc.cpp
index 6ff3c96..dd86262 100755
--- a/js/src/jsgc.cpp
+++ b/js/src/jsgc.cpp
@@ -2630,7 +2630,7 @@ GCRuntime::updatePointersToRelocatedCells(Zone* zone)
 
         gcstats::AutoPhase ap(stats, gcstats::PHASE_MARK_ROOTS);
         Debugger::markAll(&trc);
-        Debugger::markIncomingCrossCompartmentEdges(&trc);
+        //Debugger::markIncomingCrossCompartmentEdges(&trc);
 
         for (CompartmentsInZoneIter c(zone); !c.done(); c.next()) {
             c->trace(&trc);
diff --git a/js/src/jsobj.cpp b/js/src/jsobj.cpp
index 5221105..62400e6 100755
--- a/js/src/jsobj.cpp
+++ b/js/src/jsobj.cpp
@@ -3451,11 +3451,11 @@ js::DumpBacktrace(JSContext* cx)
                         script, script->pcToOffset(i.pc()));
     }
     fprintf(stdout, "%s", sprinter.string());
-#ifdef XP_WIN32
+/* #ifdef XP_WIN32
     if (IsDebuggerPresent()) {
         OutputDebugStringA(sprinter.string());
     }
-#endif
+#endif */
 }
 
 
diff --git a/js/src/vm/Debugger.cpp b/js/src/vm/Debugger.cpp
index bdbc92e..7158bd5 100755
--- a/js/src/vm/Debugger.cpp
+++ b/js/src/vm/Debugger.cpp
@@ -2376,10 +2376,10 @@ Debugger::removeAllocationsTrackingForAllDebuggees()
 }
 
 
-
+
 /*** Debugger JSObjects **************************************************************************/
 
-void
+/* void
 Debugger::markCrossCompartmentEdges(JSTracer* trc)
 {
     objects.markCrossCompartmentEdges<DebuggerObject_trace>(trc);
@@ -2418,7 +2418,7 @@ Debugger::markCrossCompartmentEdges(JSTracer* trc)
  * This method is also used during compacting GC to update cross compartment
  * pointers in zones that are not currently being compacted.
  */
-/* static */ void
+/* static void
 Debugger::markIncomingCrossCompartmentEdges(JSTracer* trc)
 {
     JSRuntime* rt = trc->runtime();
@@ -2433,7 +2433,7 @@ Debugger::markIncomingCrossCompartmentEdges(JSTracer* trc)
             dbg->markCrossCompartmentEdges(trc);
         }
     }
-}
+} */
 
 /*
  * This method has two tasks:
diff --git a/js/src/vm/Debugger.h b/js/src/vm/Debugger.h
index b291805..e0535bf 100755
--- a/js/src/vm/Debugger.h
+++ b/js/src/vm/Debugger.h
@@ -140,7 +140,7 @@ class DebuggerWeakMap : private WeakMap<PreBarriered<UnbarrieredKey>, Relocatabl
     }
 
   public:
-    template <void (traceValueEdges)(JSTracer*, JSObject*)>
+/*     template <void (traceValueEdges)(JSTracer*, JSObject*)>
     void markCrossCompartmentEdges(JSTracer* tracer) {
         for (Enum e(*static_cast<Base*>(this)); !e.empty(); e.popFront()) {
             traceValueEdges(tracer, e.front().value());
@@ -150,7 +150,7 @@ class DebuggerWeakMap : private WeakMap<PreBarriered<UnbarrieredKey>, Relocatabl
                 e.rekeyFront(key);
             key.unsafeSet(nullptr);
         }
-    }
+    } */
 
     bool hasKeyInZone(JS::Zone* zone) {
         CountMap::Ptr p = zoneCounts.lookup(zone);
@@ -521,7 +521,7 @@ class Debugger : private mozilla::LinkedListElement<Debugger>
     static void traceObject(JSTracer* trc, JSObject* obj);
     void trace(JSTracer* trc);
     static void finalize(FreeOp* fop, JSObject* obj);
-    void markCrossCompartmentEdges(JSTracer* tracer);
+    //void markCrossCompartmentEdges(JSTracer* tracer);
 
     static const Class jsclass;
 
diff --git a/js/src/vm/TaggedProto.cpp b/js/src/vm/TaggedProto.cpp
index 926cd47..dee94dc 100644
--- a/js/src/vm/TaggedProto.cpp
+++ b/js/src/vm/TaggedProto.cpp
@@ -3,18 +3,29 @@
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+ 
+#include "vm/TaggedProto.h"
 
-/* static */ void
-js::InternalGCMethods<TaggedProto>::preBarrier(TaggedProto& proto)
-{
-    InternalGCMethods<JSObject*>::preBarrier(proto.toObjectOrNull());
-}
+#include "jsfun.h"
+#include "jsobj.h"
 
-/* static */ void
-js::InternalGCMethods<TaggedProto>::postBarrier(TaggedProto* vp, TaggedProto prev, TaggedProto next)
-{
-    JSObject* prevObj = prev.isObject() ? prev.toObject() : nullptr;
-    JSObject* nextObj = next.isObject() ? next.toObject() : nullptr;
-    InternalGCMethods<JSObject*>::postBarrier(reinterpret_cast<JSObject**>(vp), prevObj,
-                                              nextObj);
-}
+#include "gc/Barrier.h"
+
+namespace js {
+
+ /* static */ void
+InternalGCMethods<TaggedProto>::preBarrier(TaggedProto& proto)
+ {
+     InternalGCMethods<JSObject*>::preBarrier(proto.toObjectOrNull());
+ }
+ 
+ /* static */ void
+InternalGCMethods<TaggedProto>::postBarrier(TaggedProto* vp, TaggedProto prev, TaggedProto next)
+ {
+     JSObject* prevObj = prev.isObject() ? prev.toObject() : nullptr;
+     JSObject* nextObj = next.isObject() ? next.toObject() : nullptr;
+     InternalGCMethods<JSObject*>::postBarrier(reinterpret_cast<JSObject**>(vp), prevObj,
+                                               nextObj);
+ }
+
+} // namespace js
diff --git a/media/mtransport/runnable_utils.h b/media/mtransport/runnable_utils.h
index 3733fcb..ba18166 100755
--- a/media/mtransport/runnable_utils.h
+++ b/media/mtransport/runnable_utils.h
@@ -13,7 +13,8 @@
 #include "mozilla/IndexSequence.h"
 #include "mozilla/Move.h"
 #include "mozilla/RefPtr.h"
-#include "mozilla/Tuple.h"
+//#include "mozilla/Tuple.h"
+#include <tuple>
 
 // Abstract base class for all of our templates
 namespace mozilla {
@@ -61,9 +62,9 @@ template<typename R>
 struct RunnableFunctionCallHelper
 {
   template<typename FunType, typename... Args, size_t... Indices>
-  static R apply(FunType func, Tuple<Args...>& args, IndexSequence<Indices...>)
+  static R apply(FunType func, std::tuple<Args...>& args, IndexSequence<Indices...>)
   {
-    return func(Get<Indices>(args)...);
+    return func(std::get<Indices>(args)...);
   }
 };
 
@@ -74,9 +75,9 @@ template<>
 struct RunnableFunctionCallHelper<void>
 {
   template<typename FunType, typename... Args, size_t... Indices>
-  static void apply(FunType func, Tuple<Args...>& args, IndexSequence<Indices...>)
+  static void apply(FunType func, std::tuple<Args...>& args, IndexSequence<Indices...>)
   {
-    func(Get<Indices>(args)...);
+    func(std::get<Indices>(args)...);
   }
 };
 
@@ -84,9 +85,9 @@ template<typename R>
 struct RunnableMethodCallHelper
 {
   template<typename Class, typename M, typename... Args, size_t... Indices>
-  static R apply(Class obj, M method, Tuple<Args...>& args, IndexSequence<Indices...>)
+  static R apply(Class obj, M method, std::tuple<Args...>& args, IndexSequence<Indices...>)
   {
-    return ((*obj).*method)(Get<Indices>(args)...);
+    return ((*obj).*method)(std::get<Indices>(args)...);
   }
 };
 
@@ -97,9 +98,9 @@ template<>
 struct RunnableMethodCallHelper<void>
 {
   template<typename Class, typename M, typename... Args, size_t... Indices>
-  static void apply(Class obj, M method, Tuple<Args...>& args, IndexSequence<Indices...>)
+  static void apply(Class obj, M method, std::tuple<Args...>& args, IndexSequence<Indices...>)
   {
-    ((*obj).*method)(Get<Indices>(args)...);
+    ((*obj).*method)(std::get<Indices>(args)...);
   }
 };
 
@@ -121,7 +122,7 @@ public:
 
 private:
   FunType mFunc;
-  Tuple<Args...> mArgs;
+  std::tuple<Args...> mArgs;
 };
 
 template<typename FunType, typename... Args>
@@ -147,7 +148,7 @@ public:
 private:
   Ret* mReturn;
   FunType mFunc;
-  Tuple<Args...> mArgs;
+  std::tuple<Args...> mArgs;
 };
 
 template<typename R, typename FunType, typename... Args>
@@ -173,7 +174,7 @@ public:
 private:
   Class mObj;
   M mMethod;
-  Tuple<Args...> mArgs;
+  std::tuple<Args...> mArgs;
 };
 
 template<typename Class, typename M, typename... Args>
@@ -200,7 +201,7 @@ private:
   Ret* mReturn;
   Class mObj;
   M mMethod;
-  Tuple<Args...> mArgs;
+  std::tuple<Args...> mArgs;
 };
 
 template<typename R, typename Class, typename M, typename... Args>
diff --git a/mfbt/Atomics.h b/mfbt/Atomics.h
index ced98ad..09f36b8 100755
--- a/mfbt/Atomics.h
+++ b/mfbt/Atomics.h
@@ -28,9 +28,7 @@
  * does not have <atomic>.  So be sure to check for <atomic> support
  * along with C++0x support.
  */
-#if defined(_MSC_VER)
-#  define MOZ_HAVE_CXX11_ATOMICS
-#elif defined(__clang__) || defined(__GNUC__)
+#if defined(__clang__) || defined(__GNUC__)
    /*
     * Clang doesn't like <atomic> from libstdc++ before 4.7 due to the
     * loose typing of the atomic builtins. GCC 4.5 and 4.6 lacks inline
@@ -44,6 +42,8 @@
 #  elif MOZ_USING_LIBCXX && defined(__clang__)
 #    define MOZ_HAVE_CXX11_ATOMICS
 #  endif
+#elif defined(_MSC_VER) > 1900
+#  define MOZ_HAVE_CXX11_ATOMICS
 #endif
 
 namespace mozilla {
@@ -267,12 +267,28 @@ struct IntrinsicAddSub<T*, Order> : public IntrinsicBase<T*, Order>
 
   static T* add(typename Base::ValueType& aPtr, ptrdiff_t aVal)
   {
-    return aPtr.fetch_add(aVal, Base::OrderedOp::AtomicRMWOrder);
+    return aPtr.fetch_add(fixupAddend(aVal), Base::OrderedOp::AtomicRMWOrder);
   }
 
   static T* sub(typename Base::ValueType& aPtr, ptrdiff_t aVal)
   {
-    return aPtr.fetch_sub(aVal, Base::OrderedOp::AtomicRMWOrder);
+    return aPtr.fetch_sub(fixupAddend(aVal), Base::OrderedOp::AtomicRMWOrder);
+  }
+private:
+  /*
+   * GCC 4.6's <atomic> header has a bug where adding X to an
+   * atomic<T*> is not the same as adding X to a T*.  Hence the need
+   * for this function to provide the correct addend.
+   */
+  static ptrdiff_t fixupAddend(ptrdiff_t aVal)
+  {
+#if defined(__clang__) || defined(_MSC_VER)
+    return aVal;
+#elif defined(__GNUC__) && !MOZ_GCC_VERSION_AT_LEAST(4, 7, 0)
+    return aVal * sizeof(T);
+#else
+    return aVal;
+#endif
   }
 };
 
@@ -484,6 +500,398 @@ struct AtomicIntrinsics<T*, Order> : public IntrinsicMemoryOps<T*, Order>,
 } // namespace detail
 } // namespace mozilla
 
+#elif defined(_MSC_VER)
+
+/*
+ * Windows comes with a full complement of atomic operations.
+ * Unfortunately, most of those aren't available for Windows XP (even if
+ * the compiler supports intrinsics for them), which is the oldest
+ * version of Windows we support.  Therefore, we only provide operations
+ * on 32-bit datatypes for 32-bit Windows versions; for 64-bit Windows
+ * versions, we support 64-bit datatypes as well.
+ */
+
+#  include <intrin.h>
+
+#  pragma intrinsic(_InterlockedExchangeAdd)
+#  pragma intrinsic(_InterlockedOr)
+#  pragma intrinsic(_InterlockedXor)
+#  pragma intrinsic(_InterlockedAnd)
+#  pragma intrinsic(_InterlockedExchange)
+#  pragma intrinsic(_InterlockedCompareExchange)
+
+namespace mozilla {
+namespace detail {
+
+#  if !defined(_M_IX86) && !defined(_M_X64)
+     /*
+      * The implementations below are optimized for x86ish systems.  You
+      * will have to modify them if you are porting to Windows on a
+      * different architecture.
+      */
+#    error "Unknown CPU type"
+#  endif
+
+/*
+ * The PrimitiveIntrinsics template should define |Type|, the datatype of size
+ * DataSize upon which we operate, and the following eight functions.
+ *
+ * static Type add(Type* aPtr, Type aVal);
+ * static Type sub(Type* aPtr, Type aVal);
+ * static Type or_(Type* aPtr, Type aVal);
+ * static Type xor_(Type* aPtr, Type aVal);
+ * static Type and_(Type* aPtr, Type aVal);
+ *
+ *   These functions perform the obvious operation on the value contained in
+ *   |*aPtr| combined with |aVal| and return the value previously stored in
+ *   |*aPtr|.
+ *
+ * static void store(Type* aPtr, Type aVal);
+ *
+ *   This function atomically stores |aVal| into |*aPtr| and must provide a full
+ *   memory fence after the store to prevent compiler and hardware instruction
+ *   reordering.  It should also act as a compiler barrier to prevent reads and
+ *   writes from moving to after the store.
+ *
+ * static Type exchange(Type* aPtr, Type aVal);
+ *
+ *   This function atomically stores |aVal| into |*aPtr| and returns the
+ *   previous contents of |*aPtr|;
+ *
+ * static bool compareExchange(Type* aPtr, Type aOldVal, Type aNewVal);
+ *
+ *   This function atomically performs the following operation:
+ *
+ *     if (*aPtr == aOldVal) {
+ *       *aPtr = aNewVal;
+ *       return true;
+ *     } else {
+ *       return false;
+ *     }
+ *
+ */
+template<size_t DataSize> struct PrimitiveIntrinsics;
+
+template<>
+struct PrimitiveIntrinsics<4>
+{
+  typedef long Type;
+
+  static Type add(Type* aPtr, Type aVal)
+  {
+    return _InterlockedExchangeAdd(aPtr, aVal);
+  }
+
+  static Type sub(Type* aPtr, Type aVal)
+  {
+    /*
+     * _InterlockedExchangeSubtract isn't available before Windows 7,
+     * and we must support Windows XP.
+     */
+    return _InterlockedExchangeAdd(aPtr, -aVal);
+  }
+
+  static Type or_(Type* aPtr, Type aVal)
+  {
+    return _InterlockedOr(aPtr, aVal);
+  }
+
+  static Type xor_(Type* aPtr, Type aVal)
+  {
+    return _InterlockedXor(aPtr, aVal);
+  }
+
+  static Type and_(Type* aPtr, Type aVal)
+  {
+    return _InterlockedAnd(aPtr, aVal);
+  }
+
+  static void store(Type* aPtr, Type aVal)
+  {
+    _InterlockedExchange(aPtr, aVal);
+  }
+
+  static Type exchange(Type* aPtr, Type aVal)
+  {
+    return _InterlockedExchange(aPtr, aVal);
+  }
+
+  static bool compareExchange(Type* aPtr, Type aOldVal, Type aNewVal)
+  {
+    return _InterlockedCompareExchange(aPtr, aNewVal, aOldVal) == aOldVal;
+  }
+};
+
+#  if defined(_M_X64)
+
+#    pragma intrinsic(_InterlockedExchangeAdd64)
+#    pragma intrinsic(_InterlockedOr64)
+#    pragma intrinsic(_InterlockedXor64)
+#    pragma intrinsic(_InterlockedAnd64)
+#    pragma intrinsic(_InterlockedExchange64)
+#    pragma intrinsic(_InterlockedCompareExchange64)
+
+template <>
+struct PrimitiveIntrinsics<8>
+{
+  typedef __int64 Type;
+
+  static Type add(Type* aPtr, Type aVal)
+  {
+    return _InterlockedExchangeAdd64(aPtr, aVal);
+  }
+
+  static Type sub(Type* aPtr, Type aVal)
+  {
+    /*
+     * There is no _InterlockedExchangeSubtract64.
+     */
+    return _InterlockedExchangeAdd64(aPtr, -aVal);
+  }
+
+  static Type or_(Type* aPtr, Type aVal)
+  {
+    return _InterlockedOr64(aPtr, aVal);
+  }
+
+  static Type xor_(Type* aPtr, Type aVal)
+  {
+    return _InterlockedXor64(aPtr, aVal);
+  }
+
+  static Type and_(Type* aPtr, Type aVal)
+  {
+    return _InterlockedAnd64(aPtr, aVal);
+  }
+
+  static void store(Type* aPtr, Type aVal)
+  {
+    _InterlockedExchange64(aPtr, aVal);
+  }
+
+  static Type exchange(Type* aPtr, Type aVal)
+  {
+    return _InterlockedExchange64(aPtr, aVal);
+  }
+
+  static bool compareExchange(Type* aPtr, Type aOldVal, Type aNewVal)
+  {
+    return _InterlockedCompareExchange64(aPtr, aNewVal, aOldVal) == aOldVal;
+  }
+};
+
+#  endif
+
+#  pragma intrinsic(_ReadWriteBarrier)
+
+template<MemoryOrdering Order> struct Barrier;
+
+/*
+ * We do not provide an afterStore method in Barrier, as Relaxed and
+ * ReleaseAcquire orderings do not require one, and the required barrier
+ * for SequentiallyConsistent is handled by PrimitiveIntrinsics.
+ */
+
+template<>
+struct Barrier<Relaxed>
+{
+  static void beforeLoad() {}
+  static void afterLoad() {}
+  static void beforeStore() {}
+};
+
+template<>
+struct Barrier<ReleaseAcquire>
+{
+  static void beforeLoad() {}
+  static void afterLoad() { _ReadWriteBarrier(); }
+  static void beforeStore() { _ReadWriteBarrier(); }
+};
+
+template<>
+struct Barrier<SequentiallyConsistent>
+{
+  static void beforeLoad() { _ReadWriteBarrier(); }
+  static void afterLoad() { _ReadWriteBarrier(); }
+  static void beforeStore() { _ReadWriteBarrier(); }
+};
+
+template<typename PrimType, typename T>
+struct CastHelper
+{
+  static PrimType toPrimType(T aVal) { return static_cast<PrimType>(aVal); }
+  static T fromPrimType(PrimType aVal) { return static_cast<T>(aVal); }
+};
+
+template<typename PrimType, typename T>
+struct CastHelper<PrimType, T*>
+{
+  static PrimType toPrimType(T* aVal) { return reinterpret_cast<PrimType>(aVal); }
+  static T* fromPrimType(PrimType aVal) { return reinterpret_cast<T*>(aVal); }
+};
+
+template<typename T>
+struct IntrinsicBase
+{
+  typedef T ValueType;
+  typedef PrimitiveIntrinsics<sizeof(T)> Primitives;
+  typedef typename Primitives::Type PrimType;
+  static_assert(sizeof(PrimType) == sizeof(T),
+                "Selection of PrimitiveIntrinsics was wrong");
+  typedef CastHelper<PrimType, T> Cast;
+};
+
+template<typename T, MemoryOrdering Order>
+struct IntrinsicMemoryOps : public IntrinsicBase<T>
+{
+  typedef typename IntrinsicBase<T>::ValueType ValueType;
+  typedef typename IntrinsicBase<T>::Primitives Primitives;
+  typedef typename IntrinsicBase<T>::PrimType PrimType;
+  typedef typename IntrinsicBase<T>::Cast Cast;
+
+  static ValueType load(const ValueType& aPtr)
+  {
+    Barrier<Order>::beforeLoad();
+    ValueType val = aPtr;
+    Barrier<Order>::afterLoad();
+    return val;
+  }
+
+  static void store(ValueType& aPtr, ValueType aVal)
+  {
+    // For SequentiallyConsistent, Primitives::store() will generate the
+    // proper memory fence.  Everything else just needs a barrier before
+    // the store.
+    if (Order == SequentiallyConsistent) {
+      Primitives::store(reinterpret_cast<PrimType*>(&aPtr),
+                        Cast::toPrimType(aVal));
+    } else {
+      Barrier<Order>::beforeStore();
+      aPtr = aVal;
+    }
+  }
+
+  static ValueType exchange(ValueType& aPtr, ValueType aVal)
+  {
+    PrimType oldval =
+      Primitives::exchange(reinterpret_cast<PrimType*>(&aPtr),
+                           Cast::toPrimType(aVal));
+    return Cast::fromPrimType(oldval);
+  }
+
+  static bool compareExchange(ValueType& aPtr, ValueType aOldVal,
+                              ValueType aNewVal)
+  {
+    return Primitives::compareExchange(reinterpret_cast<PrimType*>(&aPtr),
+                                       Cast::toPrimType(aOldVal),
+                                       Cast::toPrimType(aNewVal));
+  }
+};
+
+template<typename T>
+struct IntrinsicApplyHelper : public IntrinsicBase<T>
+{
+  typedef typename IntrinsicBase<T>::ValueType ValueType;
+  typedef typename IntrinsicBase<T>::PrimType PrimType;
+  typedef typename IntrinsicBase<T>::Cast Cast;
+  typedef PrimType (*BinaryOp)(PrimType*, PrimType);
+  typedef PrimType (*UnaryOp)(PrimType*);
+
+  static ValueType applyBinaryFunction(BinaryOp aOp, ValueType& aPtr,
+                                       ValueType aVal)
+  {
+    PrimType* primTypePtr = reinterpret_cast<PrimType*>(&aPtr);
+    PrimType primTypeVal = Cast::toPrimType(aVal);
+    return Cast::fromPrimType(aOp(primTypePtr, primTypeVal));
+  }
+
+  static ValueType applyUnaryFunction(UnaryOp aOp, ValueType& aPtr)
+  {
+    PrimType* primTypePtr = reinterpret_cast<PrimType*>(&aPtr);
+    return Cast::fromPrimType(aOp(primTypePtr));
+  }
+};
+
+template<typename T>
+struct IntrinsicAddSub : public IntrinsicApplyHelper<T>
+{
+  typedef typename IntrinsicApplyHelper<T>::ValueType ValueType;
+  typedef typename IntrinsicBase<T>::Primitives Primitives;
+
+  static ValueType add(ValueType& aPtr, ValueType aVal)
+  {
+    return applyBinaryFunction(&Primitives::add, aPtr, aVal);
+  }
+
+  static ValueType sub(ValueType& aPtr, ValueType aVal)
+  {
+    return applyBinaryFunction(&Primitives::sub, aPtr, aVal);
+  }
+};
+
+template<typename T>
+struct IntrinsicAddSub<T*> : public IntrinsicApplyHelper<T*>
+{
+  typedef typename IntrinsicApplyHelper<T*>::ValueType ValueType;
+  typedef typename IntrinsicBase<T*>::Primitives Primitives;
+
+  static ValueType add(ValueType& aPtr, ptrdiff_t aAmount)
+  {
+    return applyBinaryFunction(&Primitives::add, aPtr,
+                               (ValueType)(aAmount * sizeof(T)));
+  }
+
+  static ValueType sub(ValueType& aPtr, ptrdiff_t aAmount)
+  {
+    return applyBinaryFunction(&Primitives::sub, aPtr,
+                               (ValueType)(aAmount * sizeof(T)));
+  }
+};
+
+template<typename T>
+struct IntrinsicIncDec : public IntrinsicAddSub<T>
+{
+  typedef typename IntrinsicAddSub<T>::ValueType ValueType;
+  static ValueType inc(ValueType& aPtr) { return add(aPtr, 1); }
+  static ValueType dec(ValueType& aPtr) { return sub(aPtr, 1); }
+};
+
+template<typename T, MemoryOrdering Order>
+struct AtomicIntrinsics : public IntrinsicMemoryOps<T, Order>,
+                          public IntrinsicIncDec<T>
+{
+  typedef typename IntrinsicIncDec<T>::ValueType ValueType;
+  typedef typename IntrinsicBase<T>::Primitives Primitives;
+
+  static ValueType or_(ValueType& aPtr, T aVal)
+  {
+    return applyBinaryFunction(&Primitives::or_, aPtr, aVal);
+  }
+
+  static ValueType xor_(ValueType& aPtr, T aVal)
+  {
+    return applyBinaryFunction(&Primitives::xor_, aPtr, aVal);
+  }
+
+  static ValueType and_(ValueType& aPtr, T aVal)
+  {
+    return applyBinaryFunction(&Primitives::and_, aPtr, aVal);
+  }
+};
+
+template<typename T, MemoryOrdering Order>
+struct AtomicIntrinsics<T*, Order> : public IntrinsicMemoryOps<T*, Order>,
+                                     public IntrinsicIncDec<T*>
+{
+  typedef typename IntrinsicMemoryOps<T*, Order>::ValueType ValueType;
+  // This is required to make us be able to build with MSVC10, for unknown
+  // reasons.
+  typedef typename IntrinsicBase<T*>::Primitives Primitives;
+};
+
+} // namespace detail
+} // namespace mozilla
+
 #else
 # error "Atomic compiler intrinsics are not supported on your platform"
 #endif
@@ -495,8 +903,10 @@ namespace detail {
 template<typename T, MemoryOrdering Order>
 class AtomicBase
 {
-  static_assert(sizeof(T) == 4 || sizeof(T) == 8,
-                "mozilla/Atomics.h only supports 32-bit and 64-bit types");
+  // We only support 32-bit types on 32-bit Windows, which constrains our
+  // implementation elsewhere.  But we support pointer-sized types everywhere.
+  static_assert(sizeof(T) == 4 || (sizeof(uintptr_t) == 8 && sizeof(T) == 8),
+                "mozilla/Atomics.h only supports 32-bit and pointer-sized types");
 
 protected:
   typedef typename detail::AtomicIntrinsics<T, Order> Intrinsics;
@@ -726,7 +1136,7 @@ public:
   explicit MOZ_CONSTEXPR Atomic(bool aInit) : Base(aInit) {}
 
   // We provide boolean wrappers for the underlying AtomicBase methods.
-  MOZ_IMPLICIT operator bool() const
+  operator bool() const
   {
     return Base::Intrinsics::load(Base::mValue);
   }
diff --git a/mfbt/CheckedInt.h b/mfbt/CheckedInt.h
index 02ef8d5..f64564d 100755
--- a/mfbt/CheckedInt.h
+++ b/mfbt/CheckedInt.h
@@ -394,7 +394,7 @@ struct IsModValidImpl<T, true>
   }
 };
 
-template<typename T, bool IsSigned = IsSigned<T>::value>
+template<typename T, bool IsTSigned = IsSigned<T>::value>
 struct NegateImpl;
 
 template<typename T>
diff --git a/nsprpub/config/rules.mk b/nsprpub/config/rules.mk
index 1c8fdc9..84f6f4e 100755
--- a/nsprpub/config/rules.mk
+++ b/nsprpub/config/rules.mk
@@ -81,19 +81,18 @@ ifeq (,$(filter-out WINNT WINCE OS2,$(OS_ARCH)))
 # other platforms do not.
 #
 ifeq (,$(filter-out WIN95 WINCE WINMO OS2,$(OS_TARGET)))
+LIBRARY		= $(OBJDIR)/$(LIBRARY_NAME)$(LIBRARY_VERSION)_s.$(LIB_SUFFIX)
 SHARED_LIBRARY	= $(OBJDIR)/$(LIBRARY_NAME)$(LIBRARY_VERSION).$(DLL_SUFFIX)
 SHARED_LIB_PDB	= $(OBJDIR)/$(LIBRARY_NAME)$(LIBRARY_VERSION).pdb
-ifdef MSC_VER
-LIBRARY         = $(OBJDIR)/$(LIBRARY_NAME)$(LIBRARY_VERSION)_s.$(LIB_SUFFIX)
-IMPORT_LIBRARY  = $(OBJDIR)/$(LIBRARY_NAME)$(LIBRARY_VERSION).$(LIB_SUFFIX)
-else
-LIBRARY         = $(OBJDIR)/lib$(LIBRARY_NAME)$(LIBRARY_VERSION)_s.$(LIB_SUFFIX)
-IMPORT_LIBRARY  = $(OBJDIR)/lib$(LIBRARY_NAME)$(LIBRARY_VERSION).$(LIB_SUFFIX)
-endif
 else
+LIBRARY		= $(OBJDIR)/lib$(LIBRARY_NAME)$(LIBRARY_VERSION)_s.$(LIB_SUFFIX)
 SHARED_LIBRARY	= $(OBJDIR)/lib$(LIBRARY_NAME)$(LIBRARY_VERSION).$(DLL_SUFFIX)
 SHARED_LIB_PDB	= $(OBJDIR)/lib$(LIBRARY_NAME)$(LIBRARY_VERSION).pdb
-LIBRARY         = $(OBJDIR)/lib$(LIBRARY_NAME)$(LIBRARY_VERSION)_s.$(LIB_SUFFIX)
+endif
+
+ifdef MSC_VER
+IMPORT_LIBRARY  = $(OBJDIR)/$(LIBRARY_NAME)$(LIBRARY_VERSION).$(LIB_SUFFIX)
+else
 IMPORT_LIBRARY  = $(OBJDIR)/lib$(LIBRARY_NAME)$(LIBRARY_VERSION).$(LIB_SUFFIX)
 endif
 
diff --git a/nsprpub/configure b/nsprpub/configure
index 09c56bf..f30b1d2 100755
--- a/nsprpub/configure
+++ b/nsprpub/configure
@@ -7088,9 +7088,7 @@ tools are selected during the Xcode/Developer Tools installation." "$LINENO" 5
         _MSVC_VER_FILTER='s|.* \([0-9]\+\.[0-9]\+\.[0-9]\+\(\.[0-9]\+\)\?\).*|\1|p'
 
         CC_VERSION=`${CC} -v 2>&1 | sed -ne "$_MSVC_VER_FILTER"`
-        if test -z "$CC_VERSION"; then
-            as_fn_error $? "Could not determine MSC version." "$LINENO" 5
-        fi
+
 
         _CC_MAJOR_VERSION=`echo ${CC_VERSION} | awk -F\. '{ print $1 }'`
         _CC_MINOR_VERSION=`echo ${CC_VERSION} | awk -F\. '{ print $2 }'`
diff --git a/nsprpub/configure.in b/nsprpub/configure.in
index 836a914..93cfbd4 100755
--- a/nsprpub/configure.in
+++ b/nsprpub/configure.in
@@ -1894,9 +1894,6 @@ tools are selected during the Xcode/Developer Tools installation.])
         _MSVC_VER_FILTER='s|.* \([0-9]\+\.[0-9]\+\.[0-9]\+\(\.[0-9]\+\)\?\).*|\1|p'
         changequote([,])
         CC_VERSION=`${CC} -v 2>&1 | sed -ne "$_MSVC_VER_FILTER"`
-        if test -z "$CC_VERSION"; then
-            AC_MSG_ERROR([Could not determine MSC version.])
-        fi
 
         _CC_MAJOR_VERSION=`echo ${CC_VERSION} | awk -F\. '{ print $1 }'`
         _CC_MINOR_VERSION=`echo ${CC_VERSION} | awk -F\. '{ print $2 }'`
diff --git a/security/sandbox/chromium/sandbox/win/src/sandbox_nt_util.cc b/security/sandbox/chromium/sandbox/win/src/sandbox_nt_util.cc
index 12dd7d8..d31b131 100644
--- a/security/sandbox/chromium/sandbox/win/src/sandbox_nt_util.cc
+++ b/security/sandbox/chromium/sandbox/win/src/sandbox_nt_util.cc
@@ -365,7 +365,7 @@ UNICODE_STRING* GetImageInfoFromModule(HMODULE module, uint32* flags) {
 #pragma warning(push)
 #pragma warning(disable: 4509)
   UNICODE_STRING* out_name = NULL;
-  __try {
+  try {
     do {
       *flags = 0;
       base::win::PEImage pe(module);
@@ -388,7 +388,7 @@ UNICODE_STRING* GetImageInfoFromModule(HMODULE module, uint32* flags) {
           *flags |= MODULE_HAS_CODE;
       }
     } while (false);
-  } __except(EXCEPTION_EXECUTE_HANDLER) {
+  } catch(...) {
   }
 
   return out_name;
diff --git a/xpcom/threads/MozPromise.h b/xpcom/threads/MozPromise.h
index 036c938..7e5e765 100644
--- a/xpcom/threads/MozPromise.h
+++ b/xpcom/threads/MozPromise.h
@@ -13,7 +13,8 @@
 #include "mozilla/Maybe.h"
 #include "mozilla/Mutex.h"
 #include "mozilla/Monitor.h"
-#include "mozilla/Tuple.h"
+//#include "mozilla/Tuple.h"
+#include <tuple>
 
 #include "nsTArray.h"
 #include "nsThreadUtils.h"
@@ -864,9 +865,9 @@ namespace detail {
 template<typename ReturnType, typename ThisType, typename... ArgTypes, size_t... Indices>
 ReturnType
 MethodCallInvokeHelper(ReturnType(ThisType::*aMethod)(ArgTypes...), ThisType* aThisVal,
-                       Tuple<ArgTypes...>& aArgs, IndexSequence<Indices...>)
+                       std::tuple<ArgTypes...>& aArgs, IndexSequence<Indices...>)
 {
-  return ((*aThisVal).*aMethod)(Get<Indices>(aArgs)...);
+  return ((*aThisVal).*aMethod)(std::get<Indices>(aArgs)...);
 }
 
 // Non-templated base class to allow us to use MOZ_COUNT_{C,D}TOR, which cause
@@ -897,7 +898,7 @@ public:
 private:
   MethodType mMethod;
   nsRefPtr<ThisType> mThisVal;
-  Tuple<ArgTypes...> mArgs;
+  std::tuple<ArgTypes...> mArgs;
 };
 
 template<typename PromiseType, typename ThisType, typename ...ArgTypes>
-- 
2.6.1.windows.1

