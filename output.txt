#line 1 "limits.cpp"
#line 1 "icllimits.h"




#line 1 "limits.cpp"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\limits"

#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\ymath.h"
 
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"
 
#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xkeycheck.h"
 
#pragma once






#line 91 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xkeycheck.h"

#line 253 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xkeycheck.h"









 
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\crtdefs.h"








#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h"




























#line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h"




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"












 
#pragma once

































































































































 











#line 188 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"



#line 197 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"




#line 209 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"

#line 216 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"

#line 232 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"





























































































#line 333 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"





















#line 360 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"











































































































































#line 505 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"

#line 512 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"































#line 549 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"




























#line 585 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"














#line 605 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"

#line 612 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"









































































































#pragma region Input Buffer SAL 1 compatibility macros






























































































 




































































































































































































#line 1016 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"


























































































































































                                                




                                                






















































































































#line 1300 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"





















































































#line 1391 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"


#line 1399 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"








#line 1419 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"






























































#pragma endregion Input Buffer SAL 1 compatibility macros
























#line 1564 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"


#line 1620 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"














#line 1672 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"

#line 2067 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"




#line 2081 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"
















#line 2103 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"

#line 2111 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"






































































































































































































































































 







extern "C" {














 





 

#line 2644 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"



















 

#line 2855 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"









 

#line 2878 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"

#line 2888 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"

#line 2898 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"


    



#line 2911 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"

#line 2919 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"



#line 2931 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"



























#line 2965 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"






















}


#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\ConcurrencySal.h"













 




#pragma once


extern "C" {


#line 265 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\ConcurrencySal.h"





#line 286 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\ConcurrencySal.h"





#line 305 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\ConcurrencySal.h"











 
#line 331 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\ConcurrencySal.h"

#line 344 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\ConcurrencySal.h"










}


#line 2991 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\sal.h"

#line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vadefs.h"










#pragma once



#pragma pack(push, 8)


extern "C" {









        typedef unsigned __int64  uintptr_t;










        typedef char* va_list;









#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vadefs.h"

#line 105 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vadefs.h"

    void __cdecl __va_start(va_list* , ...);

#line 114 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vadefs.h"




} 



    extern "C++"
    {
        template <typename _Ty>
        struct __vcrt_va_list_is_reference
        {
            enum : bool { __the_value = false };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        void __vcrt_va_start_verify_argument_type() throw()
        {
            static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
        }
    } 









#pragma pack(pop)
#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h"














#line 80 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h"

__pragma(pack(push, 8)) extern "C" {























#line 118 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h"

#line 130 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h"



#line 140 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h"


#line 149 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h"































#line 188 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h"






    typedef unsigned __int64 size_t;
    typedef __int64          ptrdiff_t;
    typedef __int64          intptr_t;

























#line 229 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h"








    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper(__unaligned _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];
            

    }











#line 266 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h"





#line 279 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h"









    void __cdecl __security_init_cookie(void);





        void __cdecl __security_check_cookie( uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure( uintptr_t _StackCookie);


        
extern uintptr_t __security_cookie;
 






} __pragma(pack(pop))

#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\crtdefs.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"







#pragma once

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h"




























#line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h"

#line 11 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"

__pragma(pack(push, 8)) extern "C" {








#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"







#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"













#line 66 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"








#line 82 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"



#line 92 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"



























extern "C++"
{
    template<bool _Enable, typename _Ty>
    struct _CrtEnableIf;

    template<typename _Ty>
    struct _CrtEnableIf<true, _Ty>
    {
        typedef _Ty _Type;
    };
}



    typedef bool  __crt_bool;
















#line 157 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"
















#line 189 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"





#line 201 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"















#line 225 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"

 void __cdecl _invalid_parameter_noinfo(void);
 __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);

__declspec(noreturn)
 void __cdecl _invoke_watson(
     wchar_t const*,
     wchar_t const*,
     wchar_t const*,
           unsigned int,
           uintptr_t);






        
        
        
        
        
        
        
        
        
        
        
















#line 278 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"








#line 297 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"

#line 305 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"












#line 323 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"

#line 338 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"


















#line 367 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"











#line 388 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"

#line 397 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"


        
        
#line 407 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"

#line 419 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"

#line 427 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"

#line 436 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"












typedef int                           errno_t;
typedef unsigned short                wint_t;
typedef unsigned short                wctype_t;
typedef long                          __time32_t;
typedef __int64                       __time64_t;

typedef struct __crt_locale_data_public
{
      unsigned short const* _locale_pctype;
     int _locale_mb_cur_max;
               unsigned int _locale_lc_codepage;
} __crt_locale_data_public;

typedef struct __crt_locale_pointers
{
    struct __crt_locale_data*    locinfo;
    struct __crt_multibyte_data* mbcinfo;
} __crt_locale_pointers;

typedef __crt_locale_pointers* _locale_t; 

typedef struct _Mbstatet
{ 
    unsigned long _Wchar;
    unsigned short _Byte, _State;
} _Mbstatet;

typedef _Mbstatet mbstate_t;













        typedef __time64_t time_t;









    typedef size_t rsize_t;













#line 523 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"

#line 534 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"

#line 545 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"

#line 556 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"

#line 567 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"

#line 578 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"

#line 589 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"

#line 600 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"

#line 611 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"

#line 627 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"

#line 643 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"

#line 660 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"

#line 678 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"











































































#line 1753 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt.h"




















































































































































} __pragma(pack(pop))
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\crtdefs.h"








#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\crtdefs.h"

#line 40 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\crtdefs.h"

#line 52 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\crtdefs.h"

#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"

#pragma pack(push,8)



#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"





#line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"





#line 49 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"












 

#line 76 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"

		 
#line 87 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"
		 
#line 95 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"

		 








#line 145 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"

	 
#line 160 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"

	 
#line 173 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"

	 
#line 182 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"








		#pragma detect_mismatch("_MSC_VER", "1900")



		#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "0")




			#pragma detect_mismatch("RuntimeLibrary", "MT_StaticRelease")
#line 209 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"

#line 223 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"

 




#line 236 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"

 
 

#line 248 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"








#line 265 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"

#line 275 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"

#line 285 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"

#line 320 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"

 
#line 329 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"






#line 346 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\use_ansi.h"











 

#pragma once



















#line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\use_ansi.h"
















#pragma comment(lib, "libcpmt" "" "")










#line 348 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"









 
#line 372 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"

 
#line 381 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"

#line 389 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"

#line 397 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"

 
#line 407 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"

#line 414 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"








#line 433 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"

#line 465 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"

		 








 




#line 486 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"
 











#line 512 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"

		 





		 






typedef long long _Longlong;
typedef unsigned long long _ULonglong;

		 






		 
		 







namespace std {
enum _Uninitialized
	{	
	_Noinit
	};

		

#pragma warning(push)
#pragma warning(disable:4412)
class  _Lockit
	{	
public:


#line 578 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"
	__thiscall _Lockit();	
	explicit __thiscall _Lockit(int);	
	__thiscall ~_Lockit() noexcept;	


	static  void __cdecl _Lockit_ctor(int);
	static  void __cdecl _Lockit_dtor(int);

private:
	static  void __cdecl _Lockit_ctor(_Lockit *);
	static  void __cdecl _Lockit_ctor(_Lockit *, int);
	static  void __cdecl _Lockit_dtor(_Lockit *);

public:
	 _Lockit(const _Lockit&) = delete;
	_Lockit&  operator=(const _Lockit&) = delete;

private:
	int _Locktype;

#line 611 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"
	};

#line 684 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"














class  _Init_locks
	{	
public:
#line 714 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"
	__thiscall _Init_locks();
	__thiscall ~_Init_locks() noexcept;


private:
	static  void __cdecl _Init_locks_ctor(_Init_locks *);
	static  void __cdecl _Init_locks_dtor(_Init_locks *);

#line 731 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\yvals.h"
	};

#pragma warning(pop)
}






		 

 void __cdecl _Atexit(void (__cdecl *)(void));

typedef unsigned long _Uint32t;





 #pragma pack(pop)






 
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\ymath.h"

 #pragma pack(push,8)
 #pragma warning(push,3)






extern "C" {



		 





		 






void __cdecl _Feraise(int);

typedef union
	{	 
	unsigned short _Word[8];
	float _Float;
	double _Double;
	long double _Long_double;
	} _Dconst;

		 
 double __cdecl _Cosh(double, double);
 short __cdecl _Dtest(double *);
 double __cdecl _Sinh(double, double);

 short __cdecl _Exp(double *, double, short);
extern    _Dconst _Denorm, _Hugeval, _Inf,
	_Nan, _Snan;

		 
 float __cdecl _FCosh(float, float);
 short __cdecl _FDtest(float *);
 float __cdecl _FSinh(float, float);

 short __cdecl _FExp(float *, float, short);
extern    _Dconst _FDenorm, _FInf, _FNan, _FSnan;

		 
 long double __cdecl _LCosh(long double, long double);
 short __cdecl _LDtest(long double *);
 long double __cdecl _LSinh(long double, long double);

 short __cdecl _LExp(long double *, long double, short);
extern    _Dconst _LDenorm, _LInf, _LNan, _LSnan;



}




 #pragma warning(pop)
 #pragma pack(pop)







 
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\limits"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\cfloat"

#pragma once




#line 1 "C:\\Program Files (x86)\\IntelSWTools\\compilers_and_libraries\\windows\\compiler\\include\\float.h"







 



     
#line 1 "c:\\PROGRA~2\\INTELS~1\\COMPIL~2\\windows\\compiler\\include\\float.h"







 



     
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\float.h"








#pragma once




__pragma(pack(push, 8)) extern "C" {



#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\float.h"
















#line 58 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\float.h"








#line 79 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\float.h"

#line 95 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\float.h"

#line 108 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\float.h"










#line 124 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\float.h"






#line 137 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\float.h"



































#line 178 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\float.h"














#line 202 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\float.h"
























 unsigned int __cdecl _clearfp(void);

#pragma warning(push)
#pragma warning(disable: 4141)

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_controlfp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 unsigned int __cdecl _controlfp(
     unsigned int _NewValue,
     unsigned int _Mask
    );

#pragma warning(pop)


 void __cdecl _set_controlfp(
     unsigned int _NewValue,
     unsigned int _Mask
    );


 errno_t __cdecl _controlfp_s(
     unsigned int* _CurrentState,
          unsigned int  _NewValue,
          unsigned int  _Mask
    );


 unsigned int __cdecl _statusfp(void);


 void __cdecl _fpreset(void);

#line 267 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\float.h"





 unsigned int __cdecl _control87(
     unsigned int _NewValue,
     unsigned int _Mask
    );

#line 286 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\float.h"



 int* __cdecl __fpecode(void);




 int __cdecl __fpe_flt_rounds(void);












  double __cdecl _copysign( double _Number,  double _Sign);
  double __cdecl _chgsign( double _X);
  double __cdecl _scalb( double _X,  long _Y);
  double __cdecl _logb( double _X);
  double __cdecl _nextafter( double _X,  double _Y);
  int    __cdecl _finite( double _X);
  int    __cdecl _isnan( double _X);
  int    __cdecl _fpclass( double _X);


      float __cdecl _scalbf( float _X,  long _Y);















    
     void __cdecl fpreset(void);







    



#line 353 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\float.h"


















#line 377 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\float.h"






#line 389 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\float.h"












} __pragma(pack(pop))
#line 15 "c:\\PROGRA~2\\INTELS~1\\COMPIL~2\\windows\\compiler\\include\\float.h"
#line 45 "c:\\PROGRA~2\\INTELS~1\\COMPIL~2\\windows\\compiler\\include\\float.h"


 







extern "C" {





    extern int __cdecl __libm_flt_rounds (void) ;





}



         



#line 81 "c:\\PROGRA~2\\INTELS~1\\COMPIL~2\\windows\\compiler\\include\\float.h"


 
#line 93 "c:\\PROGRA~2\\INTELS~1\\COMPIL~2\\windows\\compiler\\include\\float.h"

#line 107 "c:\\PROGRA~2\\INTELS~1\\COMPIL~2\\windows\\compiler\\include\\float.h"

 
#line 118 "c:\\PROGRA~2\\INTELS~1\\COMPIL~2\\windows\\compiler\\include\\float.h"

#line 128 "c:\\PROGRA~2\\INTELS~1\\COMPIL~2\\windows\\compiler\\include\\float.h"

 
#line 139 "c:\\PROGRA~2\\INTELS~1\\COMPIL~2\\windows\\compiler\\include\\float.h"

#line 147 "c:\\PROGRA~2\\INTELS~1\\COMPIL~2\\windows\\compiler\\include\\float.h"


 
#line 183 "c:\\PROGRA~2\\INTELS~1\\COMPIL~2\\windows\\compiler\\include\\float.h"

#line 198 "c:\\PROGRA~2\\INTELS~1\\COMPIL~2\\windows\\compiler\\include\\float.h"


#line 270 "c:\\PROGRA~2\\INTELS~1\\COMPIL~2\\windows\\compiler\\include\\float.h"

#line 344 "c:\\PROGRA~2\\INTELS~1\\COMPIL~2\\windows\\compiler\\include\\float.h"



#line 15 "C:\\Program Files (x86)\\IntelSWTools\\compilers_and_libraries\\windows\\compiler\\include\\float.h"
#line 45 "C:\\Program Files (x86)\\IntelSWTools\\compilers_and_libraries\\windows\\compiler\\include\\float.h"


 
#line 346 "C:\\Program Files (x86)\\IntelSWTools\\compilers_and_libraries\\windows\\compiler\\include\\float.h"

#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\cfloat"





 
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\limits"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\climits"

#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\limits.h"







#pragma once


#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h"




























#line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h"

#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\limits.h"

__pragma(pack(push, 8)) extern "C" {








#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\limits.h"

#line 43 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\limits.h"




















#line 71 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\limits.h"

#line 79 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\limits.h"









} __pragma(pack(pop))
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\climits"





 
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\limits"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\cmath"

#pragma once




#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\math.h"












__pragma(pack(push, 8)) extern "C" {



#pragma warning(push)
#pragma warning(disable:4738)  
#pragma warning(disable:4820)  




    
    
    struct _exception
    {
        int    type;   
        char*  name;   
        double arg1;   
        double arg2;   
        double retval; 
    };

    
    



        struct _complex
        {
            double x, y; 
        };

#line 51 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\math.h"











    typedef float  float_t;
    typedef double double_t;





#line 75 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\math.h"






        extern double const _HUGE;


























































































void __cdecl _fperrraise( int _Except);

  short __cdecl _dclass( double _X);
  short __cdecl _ldclass( long double _X);
  short __cdecl _fdclass( float _X);

  int __cdecl _dsign( double _X);
  int __cdecl _ldsign( long double _X);
  int __cdecl _fdsign( float _X);

  int __cdecl _dpcomp( double _X,  double _Y);
  int __cdecl _ldpcomp( long double _X,  long double _Y);
  int __cdecl _fdpcomp( float _X,  float _Y);

  short __cdecl _dtest( double* _Px);
  short __cdecl _ldtest( long double* _Px);
  short __cdecl _fdtest( float* _Px);

 short __cdecl _d_int( double* _Px,  short _Xexp);
 short __cdecl _ld_int( long double* _Px,  short _Xexp);
 short __cdecl _fd_int( float* _Px,  short _Xexp);

 short __cdecl _dscale( double* _Px,  long _Lexp);
 short __cdecl _ldscale( long double* _Px,  long _Lexp);
 short __cdecl _fdscale( float* _Px,  long _Lexp);

 short __cdecl _dunscale( short* _Pex,  double* _Px);
 short __cdecl _ldunscale( short* _Pex,  long double* _Px);
 short __cdecl _fdunscale( short* _Pex,  float* _Px);

  short __cdecl _dexp( double* _Px,  double _Y,  long _Eoff);
  short __cdecl _ldexp( long double* _Px,  long double _Y,  long _Eoff);
  short __cdecl _fdexp( float* _Px,  float _Y,  long _Eoff);

  short __cdecl _dnorm( unsigned short* _Ps);
  short __cdecl _fdnorm( unsigned short* _Ps);

  double __cdecl _dpoly( double _X,  double const* _Tab,  int _N);
  long double __cdecl _ldpoly( long double _X,  long double const* _Tab,  int _N);
  float __cdecl _fdpoly( float _X,  float const* _Tab,  int _N);

  double __cdecl _dlog( double _X,  int _Baseflag);
  long double __cdecl _ldlog( long double _X,  int _Baseflag);
  float __cdecl _fdlog( float _X,  int _Baseflag);

  double __cdecl _dsin( double _X,  unsigned int _Qoff);
  long double __cdecl _ldsin( long double _X,  unsigned int _Qoff);
  float __cdecl _fdsin( float _X,  unsigned int _Qoff);


typedef union
{   
    unsigned short _Sh[4];
    double _Val;
} _double_val;


typedef union
{   
    unsigned short _Sh[2];
    float _Val;
} _float_val;


typedef union
{   
    unsigned short _Sh[4];
    long double _Val;
} _ldouble_val;

typedef union
{   
    unsigned short _Word[4];
    float _Float;
    double _Double;
    long double _Long_double;
} _float_const;

extern const _float_const _Denorm_C,  _Inf_C,  _Nan_C,  _Snan_C, _Hugeval_C;
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;

extern const _float_const _Eps_C,  _Rteps_C;
extern const _float_const _FEps_C, _FRteps_C;
extern const _float_const _LEps_C, _LRteps_C;

extern const double      _Zero_C,  _Xbig_C;
extern const float       _FZero_C, _FXbig_C;
extern const long double _LZero_C, _LXbig_C;





#line 289 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\math.h"
extern "C++"
{
     inline int fpclassify( float _X) throw()
    {
        return _fdtest(&_X);
    }

     inline int fpclassify( double _X) throw()
    {
        return _dtest(&_X);
    }

     inline int fpclassify( long double _X) throw()
    {
        return _ldtest(&_X);
    }

     inline bool signbit( float _X) throw()
    {
        return _fdsign(_X) != 0;
    }

     inline bool signbit( double _X) throw()
    {
        return _dsign(_X) != 0;
    }

     inline bool signbit( long double _X) throw()
    {
        return _ldsign(_X) != 0;
    }

     inline int _fpcomp( float _X,  float _Y) throw()
    {
        return _fdpcomp(_X, _Y);
    }

     inline int _fpcomp( double _X,  double _Y) throw()
    {
        return _dpcomp(_X, _Y);
    }

     inline int _fpcomp( long double _X,  long double _Y) throw()
    {
        return _ldpcomp(_X, _Y);
    }

    template <class _Trc, class _Tre> struct _Combined_type
    {   
        typedef float _Type;
    };

    template <> struct _Combined_type<float, double>
    {   
        typedef double _Type;
    };

    template <> struct _Combined_type<float, long double>
    {   
        typedef long double _Type;
    };

    template <class _Ty, class _T2> struct _Real_widened
    {   
        typedef long double _Type;
    };

    template <> struct _Real_widened<float, float>
    {   
        typedef float _Type;
    };

    template <> struct _Real_widened<float, double>
    {   
        typedef double _Type;
    };

    template <> struct _Real_widened<double, float>
    {   
        typedef double _Type;
    };

    template <> struct _Real_widened<double, double>
    {   
        typedef double _Type;
    };

    template <class _Ty> struct _Real_type
    {   
        typedef double _Type;   
    };

    template <> struct _Real_type<float>
    {   
        typedef float _Type;
    };

    template <> struct _Real_type<long double>
    {   
        typedef long double _Type;
    };

    template <class _T1, class _T2>
     inline int _fpcomp( _T1 _X,  _T2 _Y) throw()
    {   
        typedef typename _Combined_type<float,
            typename _Real_widened<
            typename _Real_type<_T1>::_Type,
            typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
        return _fpcomp((_Tw)_X, (_Tw)_Y);
    }

    template <class _Ty>
     inline bool isfinite( _Ty _X) throw()
    {
        return fpclassify(_X) <= 0;
    }

    template <class _Ty>
     inline bool isinf( _Ty _X) throw()
    {
        return fpclassify(_X) == 1;
    }

    template <class _Ty>
     inline bool isnan( _Ty _X) throw()
    {
        return fpclassify(_X) == 2;
    }

    template <class _Ty>
     inline bool isnormal( _Ty _X) throw()
    {
        return fpclassify(_X) == (-1);
    }

    template <class _Ty1, class _Ty2>
     inline bool isgreater( _Ty1 _X,  _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 4) != 0;
    }

    template <class _Ty1, class _Ty2>
     inline bool isgreaterequal( _Ty1 _X,  _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (2 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
     inline bool isless( _Ty1 _X,  _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 1) != 0;
    }

    template <class _Ty1, class _Ty2>
     inline bool islessequal( _Ty1 _X,  _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 2)) != 0;
    }

    template <class _Ty1, class _Ty2>
     inline bool islessgreater( _Ty1 _X,  _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
     inline bool isunordered( _Ty1 _X,  _Ty2 _Y) throw()
    {
        return _fpcomp(_X, _Y) == 0;
    }
}  






 int       __cdecl abs( int _X);
 long      __cdecl labs( long _X);
 long long __cdecl llabs( long long _X);

 double __cdecl acos( double _X);
 double __cdecl asin( double _X);
 double __cdecl atan( double _X);
 double __cdecl atan2( double _Y,  double _X);

 double __cdecl cos( double _X);
 double __cdecl cosh( double _X);
 double __cdecl exp( double _X);
  double __cdecl fabs( double _X);
 double __cdecl fmod( double _X,  double _Y);
 double __cdecl log( double _X);
 double __cdecl log10( double _X);
 double __cdecl pow( double _X,  double _Y);
 double __cdecl sin( double _X);
 double __cdecl sinh( double _X);
  double __cdecl sqrt( double _X);
 double __cdecl tan( double _X);
 double __cdecl tanh( double _X);

  double    __cdecl acosh( double _X);
  double    __cdecl asinh( double _X);
  double    __cdecl atanh( double _X);
   double    __cdecl atof( char const* _String);
   double    __cdecl _atof_l( char const* _String,  _locale_t _Locale);
  double    __cdecl _cabs( struct _complex _Complex_value);
  double    __cdecl cbrt( double _X);
  double    __cdecl ceil( double _X);
  double    __cdecl _chgsign( double _X);
  double    __cdecl copysign( double _Number,  double _Sign);
  double    __cdecl _copysign( double _Number,  double _Sign);
  double    __cdecl erf( double _X);
  double    __cdecl erfc( double _X);
  double    __cdecl exp2( double _X);
  double    __cdecl expm1( double _X);
  double    __cdecl fdim( double _X,  double _Y);
  double    __cdecl floor( double _X);
  double    __cdecl fma( double _X,  double _Y,  double _Z);
  double    __cdecl fmax( double _X,  double _Y);
  double    __cdecl fmin( double _X,  double _Y);
  double    __cdecl frexp( double _X,  int* _Y);
  double    __cdecl hypot( double _X,  double _Y);
  double    __cdecl _hypot( double _X,  double _Y);
  int       __cdecl ilogb( double _X);
  double    __cdecl ldexp( double _X,  int _Y);
  double    __cdecl lgamma( double _X);
  long long __cdecl llrint( double _X);
  long long __cdecl llround( double _X);
  double    __cdecl log1p( double _X);
  double    __cdecl log2( double _X);
  double    __cdecl logb( double _X);
  long      __cdecl lrint( double _X);
  long      __cdecl lround( double _X);

int __cdecl _matherr( struct _exception* _Except);

  double __cdecl modf( double _X,  double* _Y);
  double __cdecl nan( char const*);
  double __cdecl nearbyint( double _X);
  double __cdecl nextafter( double _X,  double _Y);
  double __cdecl nexttoward( double _X,  long double _Y);
  double __cdecl remainder( double _X,  double _Y);
  double __cdecl remquo( double _X,  double _Y,  int* _Z);
  double __cdecl rint( double _X);
  double __cdecl round( double _X);
  double __cdecl scalbln( double _X,  long _Y);
  double __cdecl scalbn( double _X,  int _Y);
  double __cdecl tgamma( double _X);
  double __cdecl trunc( double _X);
  double __cdecl _j0( double _X );
  double __cdecl _j1( double _X );
  double __cdecl _jn(int _X,  double _Y);
  double __cdecl _y0( double _X);
  double __cdecl _y1( double _X);
  double __cdecl _yn( int _X,  double _Y);

  float     __cdecl acoshf( float _X);
  float     __cdecl asinhf( float _X);
  float     __cdecl atanhf( float _X);
  float     __cdecl cbrtf( float _X);
  float     __cdecl _chgsignf( float _X);
  float     __cdecl copysignf( float _Number,  float _Sign);
  float     __cdecl _copysignf( float _Number,  float _Sign);
  float     __cdecl erff( float _X);
  float     __cdecl erfcf( float _X);
  float     __cdecl expm1f( float _X);
  float     __cdecl exp2f( float _X);
  float     __cdecl fdimf( float _X,  float _Y);
  float     __cdecl fmaf( float _X,  float _Y,  float _Z);
  float     __cdecl fmaxf( float _X,  float _Y);
  float     __cdecl fminf( float _X,  float _Y);
  float     __cdecl _hypotf( float _X,  float _Y);
  int       __cdecl ilogbf( float _X);
  float     __cdecl lgammaf( float _X);
  long long __cdecl llrintf( float _X);
  long long __cdecl llroundf( float _X);
  float     __cdecl log1pf( float _X);
  float     __cdecl log2f( float _X);
  float     __cdecl logbf( float _X);
  long      __cdecl lrintf( float _X);
  long      __cdecl lroundf( float _X);
  float     __cdecl nanf( char const*);
  float     __cdecl nearbyintf( float _X);
  float     __cdecl nextafterf( float _X,  float _Y);
  float     __cdecl nexttowardf( float _X,  long double _Y);
  float     __cdecl remainderf( float _X,  float _Y);
  float     __cdecl remquof( float _X,  float _Y,  int* _Z);
  float     __cdecl rintf( float _X);
  float     __cdecl roundf( float _X);
  float     __cdecl scalblnf( float _X,  long _Y);
  float     __cdecl scalbnf( float _X,  int _Y);
  float     __cdecl tgammaf( float _X);
  float     __cdecl truncf( float _X);







      float __cdecl _logbf( float _X);
      float __cdecl _nextafterf( float _X,  float _Y);
      int   __cdecl _finitef( float _X);
      int   __cdecl _isnanf( float _X);
      int   __cdecl _fpclassf( float _X);

      int   __cdecl _set_FMA3_enable( int _Flag);
      int   __cdecl _get_FMA3_enable(void);

#line 605 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\math.h"





      float __cdecl acosf( float _X);
      float __cdecl asinf( float _X);
      float __cdecl atan2f( float _Y,  float _X);
      float __cdecl atanf( float _X);
      float __cdecl ceilf( float _X);
      float __cdecl cosf( float _X);
      float __cdecl coshf( float _X);
      float __cdecl expf( float _X);

#line 662 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\math.h"







     __inline float __cdecl fabsf( float _X)
    {
        return (float)fabs(_X);
    }





      float __cdecl floorf( float _X);
      float __cdecl fmodf( float _X,  float _Y);

#line 694 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\math.h"

 __inline float __cdecl frexpf( float _X,  int *_Y)
{
    return (float)frexp(_X, _Y);
}

 __inline float __cdecl hypotf( float _X,  float _Y)
{
    return _hypotf(_X, _Y);
}

 __inline float __cdecl ldexpf( float _X,  int _Y)
{
    return (float)ldexp(_X, _Y);
}



      float  __cdecl log10f( float _X);
      float  __cdecl logf( float _X);
      float  __cdecl modff( float _X,  float *_Y);
      float  __cdecl powf( float _X,  float _Y);
      float  __cdecl sinf( float _X);
      float  __cdecl sinhf( float _X);
      float  __cdecl sqrtf( float _X);
      float  __cdecl tanf( float _X);
      float  __cdecl tanhf( float _X);

#line 773 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\math.h"

  long double __cdecl acoshl( long double _X);

 __inline long double __cdecl acosl( long double _X)
{
    return acos((double)_X);
}

  long double __cdecl asinhl( long double _X);

 __inline long double __cdecl asinl( long double _X)
{
    return asin((double)_X);
}

 __inline long double __cdecl atan2l( long double _Y,  long double _X)
{
    return atan2((double)_Y, (double)_X);
}

  long double __cdecl atanhl( long double _X);

 __inline long double __cdecl atanl( long double _X)
{
    return atan((double)_X);
}

  long double __cdecl cbrtl( long double _X);

 __inline long double __cdecl ceill( long double _X)
{
    return ceil((double)_X);
}

 __inline long double __cdecl _chgsignl( long double _X)
{
    return _chgsign((double)_X);
}

  long double __cdecl copysignl( long double _Number,  long double _Sign);

 __inline long double __cdecl _copysignl( long double _Number,  long double _Sign)
{
    return _copysign((double)_Number, (double)_Sign);
}

 __inline long double __cdecl coshl( long double _X)
{
    return cosh((double)_X);
}

 __inline long double __cdecl cosl( long double _X)
{
    return cos((double)_X);
}

  long double __cdecl erfl( long double _X);
  long double __cdecl erfcl( long double _X);

 __inline long double __cdecl expl( long double _X)
{
    return exp((double)_X);
}

  long double __cdecl exp2l( long double _X);
  long double __cdecl expm1l( long double _X);

 __inline long double __cdecl fabsl( long double _X)
{
    return fabs((double)_X);
}

  long double __cdecl fdiml( long double _X,  long double _Y);

 __inline long double __cdecl floorl( long double _X)
{
    return floor((double)_X);
}

  long double __cdecl fmal( long double _X,  long double _Y,  long double _Z);
  long double __cdecl fmaxl( long double _X,  long double _Y);
  long double __cdecl fminl( long double _X,  long double _Y);

 __inline long double __cdecl fmodl( long double _X,  long double _Y)
{
    return fmod((double)_X, (double)_Y);
}

 __inline long double __cdecl frexpl( long double _X,  int *_Y)
{
    return frexp((double)_X, _Y);
}

  int __cdecl ilogbl( long double _X);

 __inline long double __cdecl _hypotl( long double _X,  long double _Y)
{
    return _hypot((double)_X, (double)_Y);
}

 __inline long double __cdecl hypotl( long double _X,  long double _Y)
{
    return _hypot((double)_X, (double)_Y);
}

 __inline long double __cdecl ldexpl( long double _X,  int _Y)
{
    return ldexp((double)_X, _Y);
}

  long double __cdecl lgammal( long double _X);
  long long __cdecl llrintl( long double _X);
  long long __cdecl llroundl( long double _X);

 __inline long double __cdecl logl( long double _X)
{
    return log((double)_X);
}

 __inline long double __cdecl log10l( long double _X)
{
    return log10((double)_X);
}

  long double __cdecl log1pl( long double _X);
  long double __cdecl log2l( long double _X);
  long double __cdecl logbl( long double _X);
  long __cdecl lrintl( long double _X);
  long __cdecl lroundl( long double _X);

 __inline long double __cdecl modfl( long double _X,  long double* _Y)
{
    double _F, _I;
    _F = modf((double)_X, &_I);
    *_Y = _I;
    return _F;
}

  long double __cdecl nanl( char const*);
  long double __cdecl nearbyintl( long double _X);
  long double __cdecl nextafterl( long double _X,  long double _Y);
  long double __cdecl nexttowardl( long double _X,  long double _Y);

 __inline long double __cdecl powl( long double _X,  long double _Y)
{
    return pow((double)_X, (double)_Y);
}

  long double __cdecl remainderl( long double _X,  long double _Y);
  long double __cdecl remquol( long double _X,  long double _Y,  int* _Z);
  long double __cdecl rintl( long double _X);
  long double __cdecl roundl( long double _X);
  long double __cdecl scalblnl( long double _X,  long _Y);
  long double __cdecl scalbnl( long double _X,  int _Y);

 __inline long double __cdecl sinhl( long double _X)
{
    return sinh((double)_X);
}

 __inline long double __cdecl sinl( long double _X)
{
    return sin((double)_X);
}

 __inline long double __cdecl sqrtl( long double _X)
{
    return sqrt((double)_X);
}

 __inline long double __cdecl tanhl( long double _X)
{
    return tanh((double)_X);
}

 __inline long double __cdecl tanl( long double _X)
{
    return tan((double)_X);
}

  long double __cdecl tgammal( long double _X);
  long double __cdecl truncl( long double _X);









    
#line 971 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\math.h"





            extern double HUGE;




        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j0" ". See online help for details."))   double __cdecl j0( double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j1" ". See online help for details."))   double __cdecl j1( double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_jn" ". See online help for details."))   double __cdecl jn( int _X,  double _Y);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y0" ". See online help for details."))   double __cdecl y0( double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y1" ". See online help for details."))   double __cdecl y1( double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_yn" ". See online help for details."))   double __cdecl yn( int _X,  double _Y);





#pragma warning(pop)



} __pragma(pack(pop))





#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\cmath"




template<class _Ty>
	 inline _Ty _Pow_int(_Ty _Xx, int _Yx) noexcept
	{
	unsigned int _Nx;
	if (_Yx >= 0)
		_Nx = static_cast<unsigned int>(_Yx);
	else
		_Nx = static_cast<unsigned int>(-_Yx);

	for (_Ty _Zx = static_cast<_Ty>(1); ; _Xx *= _Xx)
		{
		if ((_Nx & 1) != 0)
			_Zx *= _Xx;
		if ((_Nx >>= 1) == 0)
			return (_Yx < 0 ? static_cast<_Ty>(1) / _Zx : _Zx);
		}
	}

 inline double abs( double _Xx) noexcept
	{
	return (:: fabs(_Xx));
	}

 inline double pow( double _Xx,  int _Yx) noexcept
	{
	return (_Pow_int(_Xx, _Yx));
	}

 inline float abs( float _Xx) noexcept
	{
	return (:: fabsf(_Xx));
	}

 inline float acos( float _Xx) noexcept
	{
	return (:: acosf(_Xx));
	}

 inline float acosh( float _Xx) noexcept
	{
	return (:: acoshf(_Xx));
	}

 inline float asin( float _Xx) noexcept
	{
	return (:: asinf(_Xx));
	}

 inline float asinh( float _Xx) noexcept
	{
	return (:: asinhf(_Xx));
	}

 inline float atan( float _Xx) noexcept
	{
	return (:: atanf(_Xx));
	}

 inline float atanh( float _Xx) noexcept
	{
	return (:: atanhf(_Xx));
	}

 inline float atan2( float _Yx,  float _Xx) noexcept
	{
	return (:: atan2f(_Yx, _Xx));
	}

 inline float cbrt( float _Xx) noexcept
	{
	return (:: cbrtf(_Xx));
	}

 inline float ceil( float _Xx) noexcept
	{
	return (:: ceilf(_Xx));
	}

 inline float copysign( float _Number,
	 float _Sign) noexcept
	{
	return (:: copysignf(_Number, _Sign));
	}

 inline float cos( float _Xx) noexcept
	{
	return (:: cosf(_Xx));
	}

 inline float cosh( float _Xx) noexcept
	{
	return (:: coshf(_Xx));
	}

 inline float erf( float _Xx) noexcept
	{
	return (:: erff(_Xx));
	}

 inline float erfc( float _Xx) noexcept
	{
	return (:: erfcf(_Xx));
	}

 inline float exp( float _Xx) noexcept
	{
	return (:: expf(_Xx));
	}

 inline float exp2( float _Xx) noexcept
	{
	return (:: exp2f(_Xx));
	}

 inline float expm1( float _Xx) noexcept
	{
	return (:: expm1f(_Xx));
	}

 inline float fabs( float _Xx) noexcept
	{
	return (:: fabsf(_Xx));
	}

 inline float fdim( float _Xx,  float _Yx) noexcept
	{
	return (:: fdimf(_Xx, _Yx));
	}

 inline float floor( float _Xx) noexcept
	{
	return (:: floorf(_Xx));
	}

 inline float fma( float _Xx,  float _Yx,
	 float _Zx) noexcept
	{
	return (:: fmaf(_Xx, _Yx, _Zx));
	}

 inline float fmax( float _Xx,  float _Yx) noexcept
	{
	return (:: fmaxf(_Xx, _Yx));
	}

 inline float fmin( float _Xx,  float _Yx) noexcept
	{
	return (:: fminf(_Xx, _Yx));
	}

 inline float fmod( float _Xx,  float _Yx) noexcept
	{
	return (:: fmodf(_Xx, _Yx));
	}

 inline float frexp( float _Xx,  int* _Yx) noexcept
	{
	return (:: frexpf(_Xx, _Yx));
	}

 inline float hypot( float _Xx,  float _Yx) noexcept
	{
	return (:: hypotf(_Xx, _Yx));
	}

 inline int ilogb( float _Xx) noexcept
	{
	return (:: ilogbf(_Xx));
	}

 inline float ldexp( float _Xx,  int _Yx) noexcept
	{
	return (:: ldexpf(_Xx, _Yx));
	}

 inline float lgamma( float _Xx) noexcept
	{
	return (:: lgammaf(_Xx));
	}

 inline long long llrint( float _Xx) noexcept
	{
	return (:: llrintf(_Xx));
	}

 inline long long llround( float _Xx) noexcept
	{
	return (:: llroundf(_Xx));
	}

 inline float log( float _Xx) noexcept
	{
	return (:: logf(_Xx));
	}

 inline float log10( float _Xx) noexcept
	{
	return (:: log10f(_Xx));
	}

 inline float log1p( float _Xx) noexcept
	{
	return (:: log1pf(_Xx));
	}

 inline float log2( float _Xx) noexcept
	{
	return (:: log2f(_Xx));
	}

 inline float logb( float _Xx) noexcept
	{
	return (:: logbf(_Xx));
	}

 inline long lrint( float _Xx) noexcept
	{
	return (:: lrintf(_Xx));
	}

 inline long lround( float _Xx) noexcept
	{
	return (:: lroundf(_Xx));
	}

 inline float modf( float _Xx,  float* _Yx) noexcept
	{
	return (:: modff(_Xx, _Yx));
	}

 inline float nearbyint( float _Xx) noexcept
	{
	return (:: nearbyintf(_Xx));
	}

 inline float nextafter( float _Xx,  float _Yx) noexcept
	{
	return (:: nextafterf(_Xx, _Yx));
	}

 inline float nexttoward( float _Xx,
	 long double _Yx) noexcept
	{
	return (:: nexttowardf(_Xx, _Yx));
	}

 inline float pow( float _Xx,
	 float _Yx) noexcept
	{
	return (:: powf(_Xx, _Yx));
	}

 inline float pow( float _Xx,  int _Yx) noexcept
	{
	return (_Pow_int(_Xx, _Yx));
	}

 inline float remainder( float _Xx,  float _Yx) noexcept
	{
	return (:: remainderf(_Xx, _Yx));
	}

 inline float remquo( float _Xx,  float _Yx,
	 int *_Zx) noexcept
	{
	return (:: remquof(_Xx, _Yx, _Zx));
	}

 inline float rint( float _Xx) noexcept
	{
	return (:: rintf(_Xx));
	}

 inline float round( float _Xx) noexcept
	{
	return (:: roundf(_Xx));
	}

 inline float scalbln( float _Xx,  long _Yx) noexcept
	{
	return (:: scalblnf(_Xx, _Yx));
	}

 inline float scalbn( float _Xx,  int _Yx) noexcept
	{
	return (:: scalbnf(_Xx, _Yx));
	}

 inline float sin( float _Xx) noexcept
	{
	return (:: sinf(_Xx));
	}

 inline float sinh( float _Xx) noexcept
	{
	return (:: sinhf(_Xx));
	}

 inline float sqrt( float _Xx) noexcept
	{
	return (:: sqrtf(_Xx));
	}

 inline float tan( float _Xx) noexcept
	{
	return (:: tanf(_Xx));
	}

 inline float tanh( float _Xx) noexcept
	{
	return (:: tanhf(_Xx));
	}

 inline float tgamma( float _Xx) noexcept
	{
	return (:: tgammaf(_Xx));
	}

 inline float trunc( float _Xx) noexcept
	{
	return (:: truncf(_Xx));
	}

 inline long double abs( long double _Xx) noexcept
	{
	return (:: fabsl(_Xx));
	}

 inline long double acos( long double _Xx) noexcept
	{
	return (:: acosl(_Xx));
	}

 inline long double acosh( long double _Xx) noexcept
	{
	return (:: acoshl(_Xx));
	}

 inline long double asin( long double _Xx) noexcept
	{
	return (:: asinl(_Xx));
	}

 inline long double asinh( long double _Xx) noexcept
	{
	return (:: asinhl(_Xx));
	}

 inline long double atan( long double _Xx) noexcept
	{
	return (:: atanl(_Xx));
	}

 inline long double atanh( long double _Xx) noexcept
	{
	return (:: atanhl(_Xx));
	}

 inline long double atan2( long double _Yx,
	 long double _Xx) noexcept
	{
	return (:: atan2l(_Yx, _Xx));
	}

 inline long double cbrt( long double _Xx) noexcept
	{
	return (:: cbrtl(_Xx));
	}

 inline long double ceil( long double _Xx) noexcept
	{
	return (:: ceill(_Xx));
	}

 inline long double copysign( long double _Number,
	 long double _Sign) noexcept
	{
	return (:: copysignl(_Number, _Sign));
	}

 inline long double cos( long double _Xx) noexcept
	{
	return (:: cosl(_Xx));
	}

 inline long double cosh( long double _Xx) noexcept
	{
	return (:: coshl(_Xx));
	}

 inline long double erf( long double _Xx) noexcept
	{
	return (:: erfl(_Xx));
	}

 inline long double erfc( long double _Xx) noexcept
	{
	return (:: erfcl(_Xx));
	}

 inline long double exp( long double _Xx) noexcept
	{
	return (:: expl(_Xx));
	}

 inline long double exp2( long double _Xx) noexcept
	{
	return (:: exp2l(_Xx));
	}

 inline long double expm1( long double _Xx) noexcept
	{
	return (:: expm1l(_Xx));
	}

 inline long double fabs( long double _Xx) noexcept
	{
	return (:: fabsl(_Xx));
	}

 inline long double fdim( long double _Xx,
	 long double _Yx) noexcept
	{
	return (:: fdiml(_Xx, _Yx));
	}

 inline long double floor( long double _Xx) noexcept
	{
	return (:: floorl(_Xx));
	}

 inline long double fma( long double _Xx,
	 long double _Yx,  long double _Zx) noexcept
	{
	return (:: fmal(_Xx, _Yx, _Zx));
	}

 inline long double fmax( long double _Xx,
	 long double _Yx) noexcept
	{
	return (:: fmaxl(_Xx, _Yx));
	}

 inline long double fmin( long double _Xx,
	 long double _Yx) noexcept
	{
	return (:: fminl(_Xx, _Yx));
	}

 inline long double fmod( long double _Xx,
	 long double _Yx) noexcept
	{
	return (:: fmodl(_Xx, _Yx));
	}

 inline long double frexp( long double _Xx,
	 int* _Yx) noexcept
	{
	return (:: frexpl(_Xx, _Yx));
	}

 inline long double hypot( long double _Xx,
	 long double _Yx) noexcept
	{
	return (:: hypotl(_Xx, _Yx));
	}

 inline int ilogb( long double _Xx) noexcept
	{
	return (:: ilogbl(_Xx));
	}

 inline long double ldexp( long double _Xx,
	 int _Yx) noexcept
	{
	return (:: ldexpl(_Xx, _Yx));
	}

 inline long double lgamma( long double _Xx) noexcept
	{
	return (:: lgammal(_Xx));
	}

 inline long long llrint( long double _Xx) noexcept
	{
	return (:: llrintl(_Xx));
	}

 inline long long llround( long double _Xx) noexcept
	{
	return (:: llroundl(_Xx));
	}

 inline long double log( long double _Xx) noexcept
	{
	return (:: logl(_Xx));
	}

 inline long double log10( long double _Xx) noexcept
	{
	return (:: log10l(_Xx));
	}

 inline long double log1p( long double _Xx) noexcept
	{
	return (:: log1pl(_Xx));
	}

 inline long double log2( long double _Xx) noexcept
	{
	return (:: log2l(_Xx));
	}

 inline long double logb( long double _Xx) noexcept
	{
	return (:: logbl(_Xx));
	}

 inline long lrint( long double _Xx) noexcept
	{
	return (:: lrintl(_Xx));
	}

 inline long lround( long double _Xx) noexcept
	{
	return (:: lroundl(_Xx));
	}

 inline long double modf( long double _Xx,
	 long double* _Yx) noexcept
	{
	return (:: modfl(_Xx, _Yx));
	}

 inline long double nearbyint( long double _Xx) noexcept
	{
	return (:: nearbyintl(_Xx));
	}

 inline long double nextafter( long double _Xx,
	 long double _Yx) noexcept
	{
	return (:: nextafterl(_Xx, _Yx));
	}

 inline long double nexttoward( long double _Xx,
	 long double _Yx) noexcept
	{
	return (:: nexttowardl(_Xx, _Yx));
	}

 inline long double pow( long double _Xx,
	 long double _Yx) noexcept
	{
	return (:: powl(_Xx, _Yx));
	}

 inline long double pow( long double _Xx,
	 int _Yx) noexcept
	{
	return (_Pow_int(_Xx, _Yx));
	}

 inline long double remainder( long double _Xx,
	 long double _Yx) noexcept
	{
	return (:: remainderl(_Xx, _Yx));
	}

 inline long double remquo( long double _Xx,
	 long double _Yx,  int *_Zx) noexcept
	{
	return (:: remquol(_Xx, _Yx, _Zx));
	}

 inline long double rint( long double _Xx) noexcept
	{
	return (:: rintl(_Xx));
	}

 inline long double round( long double _Xx) noexcept
	{
	return (:: roundl(_Xx));
	}

 inline long double scalbln( long double _Xx,
	 long _Yx) noexcept
	{
	return (:: scalblnl(_Xx, _Yx));
	}

 inline long double scalbn( long double _Xx,
	 int _Yx) noexcept
	{
	return (:: scalbnl(_Xx, _Yx));
	}

 inline long double sin( long double _Xx) noexcept
	{
	return (:: sinl(_Xx));
	}

 inline long double sinh( long double _Xx) noexcept
	{
	return (:: sinhl(_Xx));
	}

 inline long double sqrt( long double _Xx) noexcept
	{
	return (:: sqrtl(_Xx));
	}

 inline long double tan( long double _Xx) noexcept
	{
	return (:: tanl(_Xx));
	}

 inline long double tanh( long double _Xx) noexcept
	{
	return (:: tanhl(_Xx));
	}

 inline long double tgamma( long double _Xx) noexcept
	{
	return (:: tgammal(_Xx));
	}

 inline long double trunc( long double _Xx) noexcept
	{
	return (:: truncl(_Xx));
	}



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xtgmath.h"
 


#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xtr1common"

#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\cstdlib"

#pragma once




#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\stdlib.h"







#pragma once


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_malloc.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {



#line 52 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_malloc.h"

  
  __declspec(restrict)
void* __cdecl _calloc_base(
     size_t _Count,
     size_t _Size
    );

  
   __declspec(restrict)
void* __cdecl calloc(
      size_t _Count,
      size_t _Size
    );


 int __cdecl _callnewh(
     size_t _Size
    );

  
 
void* __cdecl _expand(
               void*  _Block,
      size_t _Size
    );


void __cdecl _free_base(
      void* _Block
    );


void __cdecl free(
      void* _Block
    );

  
  __declspec(restrict)
void* __cdecl _malloc_base(
     size_t _Size
    );

  
   __declspec(restrict)
void* __cdecl malloc(
      size_t _Size
    );



size_t __cdecl _msize(
     void* _Block
    );

   
  __declspec(restrict)
void* __cdecl _realloc_base(
       void*  _Block,
                                size_t _Size
    );

   
  __declspec(restrict)
void* __cdecl realloc(
      void*  _Block,
             size_t _Size
    );

   
  __declspec(restrict)
void* __cdecl _recalloc(
      void*  _Block,
             size_t _Count,
             size_t _Size
    );


void __cdecl _aligned_free(
      void* _Block
    );

  
  __declspec(restrict)
void* __cdecl _aligned_malloc(
      size_t _Size,
                        size_t _Alignment
    );

  
  __declspec(restrict)
void* __cdecl _aligned_offset_malloc(
      size_t _Size,
                        size_t _Alignment,
                        size_t _Offset
    );



size_t __cdecl _aligned_msize(
     void*  _Block,
              size_t _Alignment,
              size_t _Offset
    );

   
  __declspec(restrict)
void* __cdecl _aligned_offset_realloc(
      void*  _Block,
             size_t _Size,
                               size_t _Alignment,
                               size_t _Offset
    );

   
  __declspec(restrict)
void* __cdecl _aligned_offset_recalloc(
      void*  _Block,
             size_t _Count,
             size_t _Size,
                               size_t _Alignment,
                               size_t _Offset
    );

   
  __declspec(restrict)
void* __cdecl _aligned_realloc(
      void*  _Block,
             size_t _Size,
                               size_t _Alignment
    );

   
  __declspec(restrict)
void* __cdecl _aligned_recalloc(
      void*  _Block,
             size_t _Count,
             size_t _Size,
                               size_t _Alignment
    );

#line 211 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_malloc.h"



} __pragma(pack(pop))
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\stdlib.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_search.h"










#pragma once

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\stddef.h"







#pragma once




__pragma(pack(push, 8)) extern "C" {




    namespace std
    {
        typedef decltype(__nullptr) nullptr_t;
    }

    using ::std::nullptr_t;





 int* __cdecl _errno(void);


 errno_t __cdecl _set_errno( int _Value);
 errno_t __cdecl _get_errno( int* _Value);


#line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\stddef.h"

 extern unsigned long  __cdecl __threadid(void);

 extern uintptr_t __cdecl __threadhandle(void);



} __pragma(pack(pop))
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_search.h"

__pragma(pack(push, 8)) extern "C" {





    
     void* __cdecl bsearch_s(
                                                       void const* _Key,
         void const* _Base,
                                                       rsize_t     _NumOfElements,
                                                       rsize_t     _SizeOfElements,
         int (__cdecl* _PtFuncCompare)(void*, void const*, void const*),
                                                   void*       _Context
        );

     void __cdecl qsort_s(
         void*   _Base,
                                                            rsize_t _NumOfElements,
                                                            rsize_t _SizeOfElements,
         int (__cdecl* _PtFuncCompare)(void*, void const*, void const*),
                                                        void*   _Context
        );






 void* __cdecl bsearch(
                                                   void const* _Key,
     void const* _Base,
                                                   size_t      _NumOfElements,
                                                   size_t      _SizeOfElements,
     int (__cdecl* _PtFuncCompare)(void const*, void const*)
    );

 void __cdecl qsort(
     void*  _Base,
                                                        size_t _NumOfElements,
                                                        size_t _SizeOfElements,
     int (__cdecl* _PtFuncCompare)(void const*, void const*)
    );


 void* __cdecl _lfind_s(
                                                      void const*   _Key,
     void const*   _Base,
                                                   unsigned int* _NumOfElements,
                                                      size_t        _SizeOfElements,
     int (__cdecl* _PtFuncCompare)(void*, void const*, void const*), 
                                                      void*         _Context
    );


 void* __cdecl _lfind(
                                                      void const*   _Key,
     void const*   _Base,
                                                   unsigned int* _NumOfElements,
                                                      unsigned int  _SizeOfElements,
     int (__cdecl* _PtFuncCompare)(void const*, void const*)
    );


 void* __cdecl _lsearch_s(
                                                            void const*   _Key,
     void*         _Base,
                                                         unsigned int* _NumOfElements,
                                                            size_t        _SizeOfElements,
     int (__cdecl* _PtFuncCompare)(void*, void const*, void const*),
                                                            void*         _Context
    );


 void* __cdecl _lsearch(
                                                            void const*   _Key,
     void*         _Base,
                                                         unsigned int* _NumOfElements,
                                                            unsigned int  _SizeOfElements,
     int (__cdecl* _PtFuncCompare)(void const*, void const*)
    );




#line 179 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_search.h"





     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lfind" ". See online help for details."))
     void* __cdecl lfind(
                                                          void const*   _Key,
         void const*   _Base,
                                                       unsigned int* _NumOfElements,
                                                          unsigned int  _SizeOfElements,
         int (__cdecl* _PtFuncCompare)(void const*, void const*)
        );

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lsearch" ". See online help for details."))
     void* __cdecl lsearch(
                                                               void const*   _Key,
         void*         _Base,
                                                            unsigned int* _NumOfElements,
                                                               unsigned int  _SizeOfElements,
         int (__cdecl* _PtFuncCompare)(void const*, void const*)
        );





} __pragma(pack(pop))
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\stdlib.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_wstdlib.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {


































 errno_t __cdecl _itow_s(
                             int      _Value,
     wchar_t* _Buffer,
                             size_t   _BufferCount,
                             int      _Radix
    );






extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s(int _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw() { return _itow_s(_Value, _Buffer, _Size, _Radix); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) wchar_t* __cdecl _itow(int _Value, wchar_t *_Buffer, int _Radix);



 errno_t __cdecl _ltow_s(
                             long     _Value,
     wchar_t* _Buffer,
                             size_t   _BufferCount,
                             int      _Radix
    );






extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s(long _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw() { return _ltow_s(_Value, _Buffer, _Size, _Radix); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) wchar_t* __cdecl _ltow(long _Value, wchar_t *_Buffer, int _Radix);


 errno_t __cdecl _ultow_s(
                             unsigned long _Value,
     wchar_t*      _Buffer,
                             size_t        _BufferCount,
                             int           _Radix
    );






extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s(unsigned long _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw() { return _ultow_s(_Value, _Buffer, _Size, _Radix); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) wchar_t* __cdecl _ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix);


 double __cdecl wcstod(
                       wchar_t const* _String,
      wchar_t**      _EndPtr
    );


 double __cdecl _wcstod_l(
                       wchar_t const* _String,
      wchar_t**      _EndPtr,
                     _locale_t      _Locale
    );


 long __cdecl wcstol(
                       wchar_t const* _String,
      wchar_t**      _EndPtr,
                         int            _Radix
    );


 long __cdecl _wcstol_l(
                       wchar_t const* _String,
      wchar_t**      _EndPtr,
                         int            _Radix,
                     _locale_t      _Locale
    );


 long long __cdecl wcstoll(
                       wchar_t const* _String,
      wchar_t**      _EndPtr,
                         int            _Radix
    );


 long long __cdecl _wcstoll_l(
                       wchar_t const* _String,
      wchar_t**      _EndPtr,
                         int            _Radix,
                     _locale_t      _Locale
    );


 unsigned long __cdecl wcstoul(
                       wchar_t const* _String,
      wchar_t**      _EndPtr,
                         int            _Radix
    );


 unsigned long __cdecl _wcstoul_l(
                       wchar_t const* _String,
      wchar_t**      _EndPtr,
                         int            _Radix,
                     _locale_t      _Locale
    );


 unsigned long long __cdecl wcstoull(
                       wchar_t const* _String,
      wchar_t**      _EndPtr,
                         int            _Radix
    );


 unsigned long long __cdecl _wcstoull_l(
                       wchar_t const* _String,
      wchar_t**      _EndPtr,
                         int            _Radix,
                     _locale_t      _Locale
    );


 long double __cdecl wcstold(
                       wchar_t const* _String,
      wchar_t**      _EndPtr
    );


 long double __cdecl _wcstold_l(
                       wchar_t const* _String,
      wchar_t**      _EndPtr,
                     _locale_t      _Locale
    );


 float __cdecl wcstof(
                       wchar_t const* _String,
      wchar_t**      _EndPtr
    );


 float __cdecl _wcstof_l(
                       wchar_t const* _String,
      wchar_t**      _EndPtr,
                     _locale_t      _Locale
    );


 double __cdecl _wtof(
     wchar_t const* _String
    );


 double __cdecl _wtof_l(
       wchar_t const* _String,
     _locale_t      _Locale
    );


 int __cdecl _wtoi(
     wchar_t const* _String
    );


 int __cdecl _wtoi_l(
       wchar_t const* _String,
     _locale_t      _Locale
    );


 long __cdecl _wtol(
     wchar_t const* _String
    );


 long __cdecl _wtol_l(
       wchar_t const* _String,
     _locale_t      _Locale
    );


 long long __cdecl _wtoll(
     wchar_t const* _String
    );


 long long __cdecl _wtoll_l(
       wchar_t const* _String,
     _locale_t      _Locale
    );


 errno_t __cdecl _i64tow_s(
                             __int64  _Value,
     wchar_t* _Buffer,
                             size_t   _BufferCount,
                             int      _Radix
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 wchar_t* __cdecl _i64tow(
                       __int64  _Value,
      wchar_t* _Buffer,
                       int      _Radix
    );


 errno_t __cdecl _ui64tow_s(
                             unsigned __int64 _Value,
     wchar_t*         _Buffer,
                             size_t           _BufferCount,
                             int              _Radix
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 wchar_t* __cdecl _ui64tow(
                       unsigned __int64 _Value,
      wchar_t*         _Buffer,
                       int              _Radix
    );


 __int64 __cdecl _wtoi64(
     wchar_t const* _String
    );


 __int64 __cdecl _wtoi64_l(
       wchar_t const* _String,
     _locale_t      _Locale
    );


 __int64 __cdecl _wcstoi64(
                       wchar_t const* _String,
      wchar_t**      _EndPtr,
                         int            _Radix
    );


 __int64 __cdecl _wcstoi64_l(
                       wchar_t const* _String,
      wchar_t**      _EndPtr,
                         int            _Radix,
                     _locale_t      _Locale
    );


 unsigned __int64 __cdecl _wcstoui64(
                       wchar_t const* _String,
      wchar_t**      _EndPtr,
                         int            _Radix
    );


 unsigned __int64 __cdecl _wcstoui64_l(
                       wchar_t const* _String,
      wchar_t**      _EndPtr,
                         int            _Radix,
                     _locale_t      _Locale
    );






  wchar_t* __cdecl _wfullpath(
     wchar_t*       _Buffer,
                               wchar_t const* _Path,
                                 size_t         _BufferCount
    );




 errno_t __cdecl _wmakepath_s(
     wchar_t*       _Buffer,
                             size_t         _BufferCount,
                       wchar_t const* _Drive,
                       wchar_t const* _Dir,
                       wchar_t const* _Filename,
                       wchar_t const* _Ext
    );








extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Drive, wchar_t const* _Dir, wchar_t const* _Filename, wchar_t const* _Ext) throw() { return _wmakepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }








__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmakepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) void __cdecl _wmakepath( wchar_t *_Buffer, wchar_t const* _Drive, wchar_t const* _Dir, wchar_t const* _Filename, wchar_t const* _Ext);

 void __cdecl _wperror(
     wchar_t const* _ErrMsg
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsplitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 void __cdecl _wsplitpath(
                       wchar_t const* _FullPath,
      wchar_t*       _Drive,
      wchar_t*       _Dir,
      wchar_t*       _Filename,
      wchar_t*       _Ext
    );

 errno_t __cdecl _wsplitpath_s(
                                 wchar_t const* _FullPath,
        wchar_t*       _Drive,
                                   size_t         _DriveCount,
          wchar_t*       _Dir,
                                   size_t         _DirCount,
     wchar_t*       _Filename,
                                   size_t         _FilenameCount,
          wchar_t*       _Ext,
                                   size_t         _ExtCount
    );




extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s( wchar_t const* _Path, wchar_t (&_Drive)[_DriveSize], wchar_t (&_Dir)[_DirSize], wchar_t (&_Name)[_NameSize], wchar_t (&_Ext)[_ExtSize] ) throw() { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }








    
     errno_t __cdecl _wdupenv_s(
          wchar_t**      _Buffer,
                                                                           size_t*        _BufferCount,
                                                                              wchar_t const* _VarName
        );



     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wdupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     wchar_t* __cdecl _wgetenv(
         wchar_t const* _VarName
        );

    
    
     errno_t __cdecl _wgetenv_s(
                                    size_t*        _RequiredCount,
         wchar_t*       _Buffer,
                                     size_t         _BufferCount,
                                   wchar_t const* _VarName
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _wgetenv_s(size_t* _RequiredCount, wchar_t (&_Buffer)[_Size], wchar_t const* _VarName) throw() { return _wgetenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
#line 436 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_wstdlib.h"

    
     int __cdecl _wputenv(
         wchar_t const* _EnvString
        );

    
     errno_t __cdecl _wputenv_s(
         wchar_t const* _Name,
         wchar_t const* _Value
        );
    
     errno_t __cdecl _wsearchenv_s(
                               wchar_t const* _Filename,
                               wchar_t const* _VarName,
         wchar_t*       _Buffer,
                                 size_t         _BufferCount
        );
    
    extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s(wchar_t const* _Filename, wchar_t const* _VarName, wchar_t (&_ResultPath)[_Size]) throw() { return _wsearchenv_s(_Filename, _VarName, _ResultPath, _Size); } }





    
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsearchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) void __cdecl _wsearchenv(wchar_t const* _Filename, wchar_t const* _VarName, wchar_t *_ResultPath);






     int __cdecl _wsystem(
         wchar_t const* _Command
        );





} __pragma(pack(pop))
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\stdlib.h"


__pragma(pack(push, 8)) extern "C" {















 void __cdecl _swab(
      char* _Buf1,
      char* _Buf2,
                                                                 int   _SizeInBytes
    );












 __declspec(noreturn) void __cdecl exit( int _Code);
 __declspec(noreturn) void __cdecl _exit( int _Code);
 __declspec(noreturn) void __cdecl _Exit( int _Code);
 __declspec(noreturn) void __cdecl quick_exit( int _Code);
 __declspec(noreturn) void __cdecl abort(void);





 unsigned int __cdecl _set_abort_behavior(
     unsigned int _Flags,
     unsigned int _Mask
    );




    typedef int (__cdecl* _onexit_t)(void);










    





#line 116 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\stdlib.h"



#line 139 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\stdlib.h"
    int       __cdecl atexit(void (__cdecl*)(void));
    _onexit_t __cdecl _onexit( _onexit_t _Func);


int __cdecl at_quick_exit(void (__cdecl*)(void));









    
    typedef void (__cdecl* _purecall_handler)(void);

    
    typedef void (__cdecl* _invalid_parameter_handler)(
        wchar_t const*,
        wchar_t const*,
        wchar_t const*, 
        unsigned int,
        uintptr_t
        );

    
     _purecall_handler __cdecl _set_purecall_handler(
         _purecall_handler _Handler
        );

     _purecall_handler __cdecl _get_purecall_handler(void);

    
     _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(
         _invalid_parameter_handler _Handler
        );

     _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);

     _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(
         _invalid_parameter_handler _Handler
        );

     _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(void);



#line 198 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\stdlib.h"









  int __cdecl _set_error_mode( int _Mode);



 int* __cdecl _errno(void);


 errno_t __cdecl _set_errno( int _Value);
 errno_t __cdecl _get_errno( int* _Value);

 unsigned long* __cdecl __doserrno(void);


 errno_t __cdecl _set_doserrno( unsigned long _Value);
 errno_t __cdecl _get_doserrno( unsigned long * _Value);


 __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char** __cdecl __sys_errlist(void);


 __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int * __cdecl __sys_nerr(void);


 void __cdecl perror( char const* _ErrMsg);




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_pgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char**    __cdecl __p__pgmptr (void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_wpgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t** __cdecl __p__wpgmptr(void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_fmode" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  int*      __cdecl __p__fmode  (void);

#line 250 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\stdlib.h"


 errno_t __cdecl _get_pgmptr ( char**    _Value);


 errno_t __cdecl _get_wpgmptr( wchar_t** _Value);

 errno_t __cdecl _set_fmode  (              int       _Mode );

 errno_t __cdecl _get_fmode  (             int*      _PMode);








typedef struct _div_t
{
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t
{
    long quot;
    long rem;
} ldiv_t;

typedef struct _lldiv_t
{
    long long quot;
    long long rem;
} lldiv_t;

 int       __cdecl abs   ( int       _Number);
 long      __cdecl labs  ( long      _Number);
 long long __cdecl llabs ( long long _Number);
 __int64   __cdecl _abs64( __int64   _Number);

 unsigned short   __cdecl _byteswap_ushort( unsigned short   _Number);
 unsigned long    __cdecl _byteswap_ulong ( unsigned long    _Number);
 unsigned __int64 __cdecl _byteswap_uint64( unsigned __int64 _Number);

  div_t   __cdecl div  ( int       _Numerator,  int       _Denominator);
  ldiv_t  __cdecl ldiv ( long      _Numerator,  long      _Denominator);
  lldiv_t __cdecl lldiv( long long _Numerator,  long long _Denominator);



#pragma warning (push)
#pragma warning (disable:6540) 

unsigned int __cdecl _rotl(
     unsigned int _Value,
     int          _Shift
    );


unsigned long __cdecl _lrotl(
     unsigned long _Value,
     int           _Shift
    );

unsigned __int64 __cdecl _rotl64(
     unsigned __int64 _Value,
     int              _Shift
    );

unsigned int __cdecl _rotr(
     unsigned int _Value,
     int          _Shift
    );


unsigned long __cdecl _lrotr(
     unsigned long _Value,
     int           _Shift
    );

unsigned __int64 __cdecl _rotr64(
     unsigned __int64 _Value,
     int              _Shift
    );

#pragma warning (pop)






 void __cdecl srand( unsigned int _Seed);

  int __cdecl rand(void);








extern "C++"
{
    inline long abs(long const _X) throw()
    {
        return labs(_X);
    }

    inline long long abs(long long const _X) throw()
    {
        return llabs(_X);
    }

    inline ldiv_t div(long const _A1, long const _A2) throw()
    {
        return ldiv(_A1, _A2);
    }

    inline lldiv_t div(long long const _A1, long long const _A2) throw()
    {
        return lldiv(_A1, _A2);
    }
}











    #pragma pack(push, 4)
    typedef struct
    {
        unsigned char ld[10];
    } _LDOUBLE;
    #pragma pack(pop)



#line 407 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\stdlib.h"

typedef struct
{
    double x;
} _CRT_DOUBLE;

typedef struct
{
    float f;
} _CRT_FLOAT;





typedef struct
{
    long double x;
} _LONGDOUBLE;



#pragma pack(push, 4)
typedef struct
{
    unsigned char ld12[12];
} _LDBL12;
#pragma pack(pop)








                     double    __cdecl atof   ( char const* _String);
   int       __cdecl atoi   ( char const* _String);
                     long      __cdecl atol   ( char const* _String);
                     long long __cdecl atoll  ( char const* _String);
                     __int64   __cdecl _atoi64( char const* _String);

  double    __cdecl _atof_l  ( char const* _String,  _locale_t _Locale);
  int       __cdecl _atoi_l  ( char const* _String,  _locale_t _Locale);
  long      __cdecl _atol_l  ( char const* _String,  _locale_t _Locale);
  long long __cdecl _atoll_l ( char const* _String,  _locale_t _Locale);
  __int64   __cdecl _atoi64_l( char const* _String,  _locale_t _Locale);

  int __cdecl _atoflt ( _CRT_FLOAT*  _Result,  char const* _String);
  int __cdecl _atodbl ( _CRT_DOUBLE* _Result,  char*       _String);
  int __cdecl _atoldbl( _LDOUBLE*    _Result,  char*       _String);


 int __cdecl _atoflt_l(
        _CRT_FLOAT* _Result,
       char const* _String,
     _locale_t   _Locale
    );


 int __cdecl _atodbl_l(
        _CRT_DOUBLE* _Result,
       char*        _String,
     _locale_t    _Locale
    );



 int __cdecl _atoldbl_l(
        _LDOUBLE* _Result,
       char*     _String,
     _locale_t _Locale
    );


 float __cdecl strtof(
                       char const* _String,
      char**      _EndPtr
    );


 float __cdecl _strtof_l(
                       char const* _String,
      char**      _EndPtr,
                     _locale_t   _Locale
    );


 double __cdecl strtod(
                       char const* _String,
      char**      _EndPtr
    );


 double __cdecl _strtod_l(
                       char const* _String,
      char**      _EndPtr,
                     _locale_t   _Locale
    );


 long double __cdecl strtold(
                       char const* _String,
      char**      _EndPtr
    );


 long double __cdecl _strtold_l(
                       char const* _String,
      char**      _EndPtr,
                     _locale_t   _Locale
    );


 long __cdecl strtol(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix
    );


 long __cdecl _strtol_l(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix,
                     _locale_t   _Locale
    );


 long long __cdecl strtoll(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix
    );


 long long __cdecl _strtoll_l(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix,
                     _locale_t   _Locale
    );


 unsigned long __cdecl strtoul(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix
    );


 unsigned long __cdecl _strtoul_l(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix,
                     _locale_t   _Locale
    );


 unsigned long long __cdecl strtoull(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix
    );


 unsigned long long __cdecl _strtoull_l(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix,
                     _locale_t   _Locale
    );


 __int64 __cdecl _strtoi64(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix
    );


 __int64 __cdecl _strtoi64_l(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix,
                     _locale_t   _Locale
    );


 unsigned __int64 __cdecl _strtoui64(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix
    );


 unsigned __int64 __cdecl _strtoui64_l(
                       char const* _String,
      char**      _EndPtr,
                         int         _Radix,
                     _locale_t   _Locale
    );










 errno_t __cdecl _itoa_s(
                             int    _Value,
     char*  _Buffer,
                             size_t _BufferCount,
                             int    _Radix
    );







extern "C++" { template <size_t _Size> inline errno_t __cdecl _itoa_s(int _Value, char (&_Buffer)[_Size], int _Radix) throw() { return _itoa_s(_Value, _Buffer, _Size, _Radix); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char* __cdecl _itoa(int _Value, char *_Buffer, int _Radix);



 errno_t __cdecl _ltoa_s(
                             long   _Value,
     char*  _Buffer,
                             size_t _BufferCount,
                             int    _Radix
    );






extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s(long _Value, char (&_Buffer)[_Size], int _Radix) throw() { return _ltoa_s(_Value, _Buffer, _Size, _Radix); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char* __cdecl _ltoa(long _Value, char *_Buffer, int _Radix);



 errno_t __cdecl _ultoa_s(
                             unsigned long _Value,
     char*         _Buffer,
                             size_t        _BufferCount,
                             int           _Radix
    );






extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s(unsigned long _Value, char (&_Buffer)[_Size], int _Radix) throw() { return _ultoa_s(_Value, _Buffer, _Size, _Radix); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char* __cdecl _ultoa(unsigned long _Value, char *_Buffer, int _Radix);



 errno_t __cdecl _i64toa_s(
                             __int64 _Value,
     char*   _Buffer,
                             size_t  _BufferCount,
                             int     _Radix
    );


__declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl _i64toa(
                       __int64 _Value,
      char*   _Buffer,
                       int     _Radix
    );



 errno_t __cdecl _ui64toa_s(
                             unsigned __int64 _Value,
     char*            _Buffer,
                             size_t           _BufferCount,
                             int              _Radix
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl _ui64toa(
                       unsigned __int64 _Value,
      char*            _Buffer,
                       int              _Radix
    );















 errno_t __cdecl _ecvt_s(
     char* _Buffer,
      size_t                       _BufferCount,
      double                       _Value,
      int                          _DigitCount,
     int*                         _PtDec,
     int*                         _PtSign
    );








extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(char (&_Buffer)[_Size], double _Value, int _DigitCount, int* _PtDec, int* _PtSign) throw() { return _ecvt_s(_Buffer, _Size, _Value, _DigitCount, _PtDec, _PtSign); } }

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl _ecvt(
      double _Value,
      int    _DigitCount,
     int*   _PtDec,
     int*   _PtSign
    );



 errno_t __cdecl _fcvt_s(
     char*  _Buffer,
                             size_t _BufferCount,
                             double _Value,
                             int    _FractionalDigitCount,
                            int*   _PtDec,
                            int*   _PtSign
    );









extern "C++" { template <size_t _Size> inline errno_t __cdecl _fcvt_s(char (&_Buffer)[_Size], double _Value, int _FractionalDigitCount, int* _PtDec, int* _PtSign) throw() { return _fcvt_s(_Buffer, _Size, _Value, _FractionalDigitCount, _PtDec, _PtSign); } }


 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl _fcvt(
      double _Value,
      int    _FractionalDigitCount,
     int*   _PtDec,
     int*   _PtSign
    );


 errno_t __cdecl _gcvt_s(
     char*  _Buffer,
                             size_t _BufferCount,
                             double _Value,
                             int    _DigitCount
    );







extern "C++" { template <size_t _Size> inline errno_t __cdecl _gcvt_s(char (&_Buffer)[_Size], double _Value, int _DigitCount) throw() { return _gcvt_s(_Buffer, _Size, _Value, _DigitCount); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_gcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl _gcvt(
                       double _Value,
                       int    _DigitCount,
      char*  _Buffer
    );










#line 828 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\stdlib.h"







    
     int __cdecl ___mb_cur_max_func(void);

    
     int __cdecl ___mb_cur_max_l_func(_locale_t);





 int __cdecl mblen(
      char const* _Ch,
                                            size_t      _MaxCount
    );

 
 int __cdecl _mblen_l(
      char const* _Ch,
                                            size_t      _MaxCount,
                                        _locale_t   _Locale
    );



 size_t __cdecl _mbstrlen(
     char const* _String
    );



 size_t __cdecl _mbstrlen_l(
       char const* _String, 
     _locale_t   _Locale
    );



 size_t __cdecl _mbstrnlen(
     char const* _String,
       size_t      _MaxCount
    );



 size_t __cdecl _mbstrnlen_l(
       char const* _String,
         size_t      _MaxCount,
     _locale_t   _Locale
    );


 int __cdecl mbtowc(
                    wchar_t*    _DstCh,
     char const* _SrcCh,
                                     size_t      _SrcSizeInBytes
    );


 int __cdecl _mbtowc_l(
                    wchar_t*    _DstCh,
     char const* _SrcCh,
                                     size_t      _SrcSizeInBytes,
                                 _locale_t   _Locale
    );


 errno_t __cdecl mbstowcs_s(
                                                     size_t*     _PtNumOfCharConverted,
     wchar_t*    _DstBuf,
                                                          size_t      _SizeInWords,
                                    char const* _SrcBuf,
                                                          size_t      _MaxCount
    );







extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s(size_t* _PtNumOfCharConverted, wchar_t (&_Dest)[_Size], char const* _Source, size_t _MaxCount) throw() { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbstowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) size_t __cdecl mbstowcs( wchar_t *_Dest, char const* _Source, size_t _MaxCount);


 errno_t __cdecl _mbstowcs_s_l(
                                                     size_t*     _PtNumOfCharConverted,
     wchar_t*    _DstBuf,
                                                          size_t      _SizeInWords,
                                    char const* _SrcBuf,
                                                          size_t      _MaxCount,
                                                      _locale_t   _Locale
    );








extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(size_t* _PtNumOfCharConverted, wchar_t (&_Dest)[_Size], char const* _Source, size_t _MaxCount, _locale_t _Locale) throw() { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }








__declspec(deprecated("This function or variable may be unsafe. Consider using " "_mbstowcs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) size_t __cdecl _mbstowcs_l( wchar_t *_Dest, char const* _Source, size_t _MaxCount, _locale_t _Locale);




__declspec(deprecated("This function or variable may be unsafe. Consider using " "wctomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 int __cdecl wctomb(
     char*   _MbCh,
                               wchar_t _WCh
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctomb_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 int __cdecl _wctomb_l(
      char*     _MbCh,
                         wchar_t   _WCh,
                     _locale_t _Locale
    );



    
     errno_t __cdecl wctomb_s(
                                                        int*    _SizeConverted,
         char*   _MbCh,
                                                             rsize_t _SizeInBytes,
                                                             wchar_t _WCh
        );




 errno_t __cdecl _wctomb_s_l(
                            int*     _SizeConverted,
     char*     _MbCh,
                                 size_t    _SizeInBytes,
                                 wchar_t   _WCh, 
                             _locale_t _Locale);


 errno_t __cdecl wcstombs_s(
                                                              size_t*        _PtNumOfCharConverted,
     char*          _Dst,
                                                                   size_t         _DstSizeInBytes,
                                                                 wchar_t const* _Src,
                                                                   size_t         _MaxCountInBytes
    );







extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s(size_t* _PtNumOfCharConverted, char (&_Dest)[_Size], wchar_t const* _Source, size_t _MaxCount) throw() { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) size_t __cdecl wcstombs( char *_Dest, wchar_t const* _Source, size_t _MaxCount);


 errno_t __cdecl _wcstombs_s_l(
                                                              size_t*        _PtNumOfCharConverted,
     char*          _Dst,
                                                                   size_t         _DstSizeInBytes,
                                                                 wchar_t const* _Src,
                                                                   size_t         _MaxCountInBytes,
                                                               _locale_t      _Locale
    );








extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l(size_t* _PtNumOfCharConverted, char (&_Dest)[_Size], wchar_t const* _Source, size_t _MaxCount, _locale_t _Locale) throw() { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }








__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcstombs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) size_t __cdecl _wcstombs_l( char *_Dest, wchar_t const* _Source, size_t _MaxCount, _locale_t _Locale);






















  char* __cdecl _fullpath(
     char*       _Buffer,
                               char const* _Path,
                                 size_t      _BufferCount
    );




 errno_t __cdecl _makepath_s(
     char*       _Buffer,
                             size_t      _BufferCount,
                       char const* _Drive,
                       char const* _Dir,
                       char const* _Filename,
                       char const* _Ext
    );








extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(char (&_Buffer)[_Size], char const* _Drive, char const* _Dir, char const* _Filename, char const* _Ext) throw() { return _makepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }








__declspec(deprecated("This function or variable may be unsafe. Consider using " "_makepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) void __cdecl _makepath( char *_Buffer, char const* _Drive, char const* _Dir, char const* _Filename, char const* _Ext);

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_splitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 void __cdecl _splitpath(
                       char const* _FullPath,
      char*       _Drive,
      char*       _Dir,
      char*       _Filename,
      char*       _Ext
    );


 errno_t __cdecl _splitpath_s(
                                 char const* _FullPath,
        char*       _Drive,
                                   size_t      _DriveCount,
          char*       _Dir,
                                   size_t      _DirCount,
     char*       _Filename,
                                   size_t      _FilenameCount,
          char*       _Ext,
                                   size_t      _ExtCount
    );

extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s( char const* _Dest, char (&_Drive)[_DriveSize], char (&_Dir)[_DirSize], char (&_Name)[_NameSize], char (&_Ext)[_ExtSize] ) throw() { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }












    
    
     errno_t __cdecl getenv_s(
                                    size_t*     _RequiredCount,
         char*       _Buffer,
                                     rsize_t     _BufferCount,
                                   char const* _VarName
        );
    





     int*       __cdecl __p___argc (void);
     char***    __cdecl __p___argv (void);
     wchar_t*** __cdecl __p___wargv(void);

#line 1159 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\stdlib.h"
    
     char***    __cdecl __p__environ (void);
     wchar_t*** __cdecl __p__wenviron(void);




    
#line 1176 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\stdlib.h"



    




     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_dupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) 
     char* __cdecl getenv(
         char const* _VarName
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s(size_t* _RequiredCount, char (&_Buffer)[_Size], char const* _VarName) throw() { return getenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }











    
     errno_t __cdecl _dupenv_s(
          char**      _Buffer,
                                                                           size_t*     _BufferCount,
                                                                              char const* _VarName
        );





     int __cdecl system(
         char const* _Command
        );

    
    
    #pragma warning (push)
    #pragma warning (disable:6540)

    
     int __cdecl _putenv(
         char const* _EnvString
        );

    
     errno_t __cdecl _putenv_s(
         char const* _Name,
         char const* _Value
        );

    #pragma warning (pop)

     errno_t __cdecl _searchenv_s(
                               char const* _Filename,
                               char const* _VarName,
         char*       _Buffer,
                                 size_t      _BufferCount
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s(char const* _Filename, char const* _VarName, char (&_Buffer)[_Size]) throw() { return _searchenv_s(_Filename, _VarName, _Buffer, _Size); } }






    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_searchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) void __cdecl _searchenv(char const* _Filename, char const* _VarName, char *_Buffer);






    
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetErrorMode" " " "instead. See online help for details."))
     void __cdecl _seterrormode(
         int _Mode
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Beep" " " "instead. See online help for details."))
     void __cdecl _beep(
         unsigned _Frequency,
         unsigned _Duration
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Sleep" " " "instead. See online help for details."))
     void __cdecl _sleep(
         unsigned long _Duration
        );




















    #pragma warning(push)
    #pragma warning(disable: 4141) 

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ecvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl ecvt(
          double _Value,
          int    _DigitCount,
         int*   _PtDec,
         int*   _PtSign
        );

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl fcvt(
          double _Value,
          int    _FractionalDigitCount,
         int*   _PtDec,
         int*   _PtSign
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_gcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl gcvt(
                           double _Value,
                           int    _DigitCount,
          char*  _DstBuf
        );
    
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_itoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl itoa(
                           int   _Value,
          char* _Buffer,
                           int   _Radix
        );
    
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ltoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl ltoa(
                           long  _Value,
          char* _Buffer,
                           int   _Radix
        );


    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_swab" ". See online help for details."))
     void __cdecl swab(
         char* _Buf1,
         char* _Buf2,
                                    int   _SizeInBytes
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ultoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl ultoa(
                           unsigned long _Value,
          char*         _Buffer,
                           int           _Radix
        );





         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putenv" ". See online help for details."))
         int __cdecl putenv(
             char const* _EnvString
            );



    #pragma warning(pop)

    _onexit_t __cdecl onexit( _onexit_t _Func);





} __pragma(pack(pop))
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\cstdlib"



namespace std {
using :: size_t; using :: div_t; using :: ldiv_t;
using :: abort; using :: abs; using :: atexit;
using :: atof; using :: atoi; using :: atol;
using :: bsearch; using :: calloc; using :: div;
using :: exit; using :: free;
using :: labs; using :: ldiv; using :: malloc;
using :: mblen; using :: mbstowcs; using :: mbtowc;
using :: qsort; using :: rand; using :: realloc;
using :: srand; using :: strtod; using :: strtol;
using :: strtoul;
using :: wcstombs; using :: wctomb;

using :: lldiv_t;


using :: getenv;
using :: system;


using :: atoll; using :: llabs; using :: lldiv;
using :: strtof; using :: strtold;
using :: strtoll; using :: strtoull;

using :: _Exit; using :: at_quick_exit; using :: quick_exit;
}







 
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xtr1common"

 #pragma pack(push,8)
 #pragma warning(push,3)



namespace std {
	
struct _Nil
	{	
	};

	
template<class _Ty,
	_Ty _Val>
	struct integral_constant
	{	
	static constexpr _Ty value = _Val;

	typedef _Ty value_type;
	typedef integral_constant<_Ty, _Val> type;

	constexpr operator value_type() const noexcept
		{	
		return (value);
		}

	constexpr value_type operator()() const noexcept
		{	
		return (value);
		}
	};

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;

	
template<bool _Val>
	using bool_constant = integral_constant<bool, _Val>;

	
template<bool _Val>
	struct _Cat_base
		: integral_constant<bool, _Val>
	{	
	};

	
template<bool _Test,
	class _Ty = void>
	struct enable_if
	{	
	};

template<class _Ty>
	struct enable_if<true, _Ty>
	{	
	typedef _Ty type;
	};

	
template<bool _Test,
	class _Ty1,
	class _Ty2>
	struct conditional
	{	
	typedef _Ty2 type;
	};

template<class _Ty1,
	class _Ty2>
	struct conditional<true, _Ty1, _Ty2>
	{	
	typedef _Ty1 type;
	};

	
template<class _Ty1,
	class _Ty2>
	struct is_same
		: false_type
	{	
	};

template<class _Ty1>
	struct is_same<_Ty1, _Ty1>
		: true_type
	{	
	};

	
template<class _Ty>
	struct remove_const
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_const<const _Ty>
	{	
	typedef _Ty type;
	};

	
template<class _Ty>
	struct remove_volatile
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_volatile<volatile _Ty>
	{	
	typedef _Ty type;
	};

	
template<class _Ty>
	struct remove_cv
	{	
	typedef typename remove_const<typename remove_volatile<_Ty>::type>::type
		type;
	};

	
template<class _Ty>
	struct _Is_integral
		: false_type
	{	
	};

template<>
	struct _Is_integral<bool>
		: true_type
	{	
	};

template<>
	struct _Is_integral<char>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned char>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed char>
		: true_type
	{	
	};


template<>
	struct _Is_integral<wchar_t>
		: true_type
	{	
	};


template<>
	struct _Is_integral<unsigned short>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed short>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned int>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed int>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned long>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed long>
		: true_type
	{	
	};

template<>
	struct _Is_integral<char16_t>
		: true_type
	{	
	};

template<>
	struct _Is_integral<char32_t>
		: true_type
	{	
	};


template<>
	struct _Is_integral<long long>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned long long>
		: true_type
	{	
	};


	
template<class _Ty>
	struct is_integral
		: _Is_integral<typename remove_cv<_Ty>::type>
	{	
	};

	
template<class _Ty>
	struct _Is_floating_point
		: false_type
	{	
	};

template<>
	struct _Is_floating_point<float>
		: true_type
	{	
	};

template<>
	struct _Is_floating_point<double>
		: true_type
	{	
	};

template<>
	struct _Is_floating_point<long double>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_floating_point
		: _Is_floating_point<typename remove_cv<_Ty>::type>
	{	
	};

	
template<class _Ty>
	struct is_arithmetic
		: _Cat_base<is_integral<_Ty>::value
			|| is_floating_point<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct remove_reference
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_reference<_Ty&>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_reference<_Ty&&>
	{	
	typedef _Ty type;
	};

	
struct _Wrap_int
	{	
	_Wrap_int(int)
		{	
		}
	};

template<class _Ty>
	struct _Identity
	{	
	typedef _Ty type;
	};

#line 325 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xtr1common"
}

 #pragma warning(pop)
 #pragma pack(pop)






 
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xtgmath.h"

 #pragma pack(push,8)
 #pragma warning(push,3)



namespace std {
template<class _Ty>
	struct _Promote_to_float
	{	
	typedef typename conditional<is_integral<_Ty>::value,
		double, _Ty>::type type;
	};

template<class _Ty1,
	class _Ty2>
	struct _Common_float_type
	{	
	typedef typename _Promote_to_float<_Ty1>::type _Ty1f;
	typedef typename _Promote_to_float<_Ty2>::type _Ty2f;
	typedef typename conditional<is_same<_Ty1f, long double>::value
		|| is_same<_Ty2f, long double>::value, long double,
		typename conditional<is_same<_Ty1f, double>::value
			|| is_same<_Ty2f, double>::value, double,
			float>::type>::type type;
	};
}




#line 48 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xtgmath.h"

#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xtgmath.h"

#line 71 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xtgmath.h"





template<class _Ty1,
	class _Ty2> inline
	typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value
		&& ::std:: is_arithmetic<_Ty2>::value,
		typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type
	pow(const _Ty1 _Left, const _Ty2 _Right)
	{	
	typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
	return (:: pow(type(_Left), type(_Right)));
	}


extern "C" double __cdecl acos(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acos(_Ty _Left) { return (:: acos((double)_Left)); }
extern "C" double __cdecl asin(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asin(_Ty _Left) { return (:: asin((double)_Left)); }
extern "C" double __cdecl atan(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atan(_Ty _Left) { return (:: atan((double)_Left)); }
extern "C" double __cdecl atan2( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type atan2(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: atan2((type)_Left, (type)_Right)); }
extern "C" double __cdecl ceil(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ceil(_Ty _Left) { return (:: ceil((double)_Left)); }
extern "C" double __cdecl cos(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cos(_Ty _Left) { return (:: cos((double)_Left)); }
extern "C" double __cdecl cosh(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cosh(_Ty _Left) { return (:: cosh((double)_Left)); }
extern "C" double __cdecl exp(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp(_Ty _Left) { return (:: exp((double)_Left)); }

extern "C" double __cdecl fabs(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type fabs(_Ty _Left) { return (:: fabs((double)_Left)); }

extern "C" double __cdecl floor(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type floor(_Ty _Left) { return (:: floor((double)_Left)); }
extern "C" double __cdecl fmod( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmod(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmod((type)_Left, (type)_Right)); }
extern "C" double __cdecl frexp(double, int *); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type frexp(_Ty _Left, int * _Arg2) { return (:: frexp((double)_Left, _Arg2)); }
extern "C" double __cdecl ldexp(double, int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ldexp(_Ty _Left, int _Arg2) { return (:: ldexp((double)_Left, _Arg2)); }
extern "C" double __cdecl log(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log(_Ty _Left) { return (:: log((double)_Left)); }
extern "C" double __cdecl log10(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log10(_Ty _Left) { return (:: log10((double)_Left)); }


extern "C" double __cdecl sin(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sin(_Ty _Left) { return (:: sin((double)_Left)); }
extern "C" double __cdecl sinh(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sinh(_Ty _Left) { return (:: sinh((double)_Left)); }
extern "C" double __cdecl sqrt(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sqrt(_Ty _Left) { return (:: sqrt((double)_Left)); }
extern "C" double __cdecl tan(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tan(_Ty _Left) { return (:: tan((double)_Left)); }
extern "C" double __cdecl tanh(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tanh(_Ty _Left) { return (:: tanh((double)_Left)); }

		
#line 122 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xtgmath.h"

		

inline float _Fma(float _Left, float _Middle, float _Right)
	{	
	return (:: fmaf(_Left, _Middle, _Right));
	}

inline double _Fma(double _Left, double _Middle, double _Right)
	{	
	return (:: fma(_Left, _Middle, _Right));
	}

inline long double _Fma(long double _Left, long double _Middle,
	long double _Right)
	{	
	return (:: fmal(_Left, _Middle, _Right));
	}

template<class _Ty1,
	class _Ty2,
	class _Ty3> inline
	typename ::std:: _Common_float_type<_Ty1,
		typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type
	fma(_Ty1 _Left, _Ty2 _Middle, _Ty3 _Right)
	{	
	typedef typename ::std:: _Common_float_type<_Ty1,
		typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type type;
	return (_Fma((type)_Left, (type)_Middle, (type)_Right));
	}

		

inline float _Remquo(float _Left, float _Right, int *_Pquo)
	{	
	return (:: remquof(_Left, _Right, _Pquo));
	}

inline double _Remquo(double _Left, double _Right, int *_Pquo)
	{	
	return (:: remquo(_Left, _Right, _Pquo));
	}

inline long double _Remquo(long double _Left, long double _Right, int *_Pquo)
	{	
	return (:: remquol(_Left, _Right, _Pquo));
	}

template<class _Ty1,
	class _Ty2> inline
	typename ::std:: _Common_float_type<_Ty1, _Ty2>::type
	remquo(_Ty1 _Left, _Ty2 _Right, int *_Pquo)
	{	
	typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
	return (_Remquo((type)_Left, (type)_Right, _Pquo));
	}

extern "C" double __cdecl acosh(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acosh(_Ty _Left) { return (:: acosh((double)_Left)); }
extern "C" double __cdecl asinh(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asinh(_Ty _Left) { return (:: asinh((double)_Left)); }
extern "C" double __cdecl atanh(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atanh(_Ty _Left) { return (:: atanh((double)_Left)); }
extern "C" double __cdecl cbrt(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cbrt(_Ty _Left) { return (:: cbrt((double)_Left)); }
extern "C" double __cdecl copysign( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type copysign(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: copysign((type)_Left, (type)_Right)); }
extern "C" double __cdecl erf(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type erf(_Ty _Left) { return (:: erf((double)_Left)); }
extern "C" double __cdecl erfc(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type erfc(_Ty _Left) { return (:: erfc((double)_Left)); }
extern "C" double __cdecl expm1(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type expm1(_Ty _Left) { return (:: expm1((double)_Left)); }
extern "C" double __cdecl exp2(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp2(_Ty _Left) { return (:: exp2((double)_Left)); }
extern "C" double __cdecl fdim( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fdim(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fdim((type)_Left, (type)_Right)); }

extern "C" double __cdecl fmax( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmax(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmax((type)_Left, (type)_Right)); }
extern "C" double __cdecl fmin( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmin(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmin((type)_Left, (type)_Right)); }
extern "C" double __cdecl hypot( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type hypot(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: hypot((type)_Left, (type)_Right)); }
extern "C" int __cdecl ilogb(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, int>::type ilogb(_Ty _Left) { return (:: ilogb((double)_Left)); }
extern "C" double __cdecl lgamma(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type lgamma(_Ty _Left) { return (:: lgamma((double)_Left)); }
extern "C" long long __cdecl llrint(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long long>::type llrint(_Ty _Left) { return (:: llrint((double)_Left)); }
extern "C" long long __cdecl llround(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long long>::type llround(_Ty _Left) { return (:: llround((double)_Left)); }
extern "C" double __cdecl log1p(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log1p(_Ty _Left) { return (:: log1p((double)_Left)); }
extern "C" double __cdecl log2(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log2(_Ty _Left) { return (:: log2((double)_Left)); }
extern "C" double __cdecl logb(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type logb(_Ty _Left) { return (:: logb((double)_Left)); }
extern "C" long __cdecl lrint(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long>::type lrint(_Ty _Left) { return (:: lrint((double)_Left)); }
extern "C" long __cdecl lround(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long>::type lround(_Ty _Left) { return (:: lround((double)_Left)); }
extern "C" double __cdecl nearbyint(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type nearbyint(_Ty _Left) { return (:: nearbyint((double)_Left)); }
extern "C" double __cdecl nextafter( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type nextafter(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: nextafter((type)_Left, (type)_Right)); }
extern "C" double __cdecl nexttoward(double, long double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type nexttoward(_Ty _Left, long double _Arg2) { return (:: nexttoward((double)_Left, _Arg2)); }
extern "C" double __cdecl remainder( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type remainder(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: remainder((type)_Left, (type)_Right)); }

extern "C" double __cdecl rint(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type rint(_Ty _Left) { return (:: rint((double)_Left)); }
extern "C" double __cdecl round(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type round(_Ty _Left) { return (:: round((double)_Left)); }
extern "C" double __cdecl scalbln(double, long); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type scalbln(_Ty _Left, long _Arg2) { return (:: scalbln((double)_Left, _Arg2)); }
extern "C" double __cdecl scalbn(double, int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type scalbn(_Ty _Left, int _Arg2) { return (:: scalbn((double)_Left, _Arg2)); }
extern "C" double __cdecl tgamma(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tgamma(_Ty _Left) { return (:: tgamma((double)_Left)); }
extern "C" double __cdecl trunc(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type trunc(_Ty _Left) { return (:: trunc((double)_Left)); }


 #pragma warning(pop)
 #pragma pack(pop)







 
#line 657 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\cmath"



namespace std {
using :: abs; using :: acos; using :: asin;
using :: atan; using :: atan2; using :: ceil;
using :: cos; using :: cosh; using :: exp;
using :: fabs; using :: floor; using :: fmod;
using :: frexp; using :: ldexp; using :: log;
using :: log10; using :: modf; using :: pow;
using :: sin; using :: sinh; using :: sqrt;
using :: tan; using :: tanh;

using :: acosf; using :: asinf;
using :: atanf; using :: atan2f; using :: ceilf;
using :: cosf; using :: coshf; using :: expf;
using :: fabsf; using :: floorf; using :: fmodf;
using :: frexpf; using :: ldexpf; using :: logf;
using :: log10f; using :: modff; using :: powf;
using :: sinf; using :: sinhf; using :: sqrtf;
using :: tanf; using :: tanhf;

using :: acosl; using :: asinl;
using :: atanl; using :: atan2l; using :: ceill;
using :: cosl; using :: coshl; using :: expl;
using :: fabsl; using :: floorl; using :: fmodl;
using :: frexpl; using :: ldexpl; using :: logl;
using :: log10l; using :: modfl; using :: powl;
using :: sinl; using :: sinhl; using :: sqrtl;
using :: tanl; using :: tanhl;

using :: float_t; using :: double_t;

using :: acosh; using :: asinh; using :: atanh;
using :: cbrt; using :: erf; using :: erfc;
using :: expm1; using :: exp2;
using :: hypot; using :: ilogb; using :: lgamma;
using :: log1p; using :: log2; using :: logb;
using :: llrint; using :: lrint; using :: nearbyint;
using :: rint; using :: llround; using :: lround;
using :: fdim; using :: fma; using :: fmax; using :: fmin;
using :: round; using :: trunc;
using :: remainder; using :: remquo;
using :: copysign; using :: nan; using :: nextafter;
using :: scalbn; using :: scalbln;
using :: nexttoward; using :: tgamma;

using :: acoshf; using :: asinhf; using :: atanhf;
using :: cbrtf; using :: erff; using :: erfcf;
using :: expm1f; using :: exp2f;
using :: hypotf; using :: ilogbf; using :: lgammaf;
using :: log1pf; using :: log2f; using :: logbf;
using :: llrintf; using :: lrintf; using :: nearbyintf;
using :: rintf; using :: llroundf; using :: lroundf;
using :: fdimf; using :: fmaf; using :: fmaxf; using :: fminf;
using :: roundf; using :: truncf;
using :: remainderf; using :: remquof;
using :: copysignf; using :: nanf;
using :: nextafterf; using :: scalbnf; using :: scalblnf;
using :: nexttowardf; using :: tgammaf;

using :: acoshl; using :: asinhl; using :: atanhl;
using :: cbrtl; using :: erfl; using :: erfcl;
using :: expm1l; using :: exp2l;
using :: hypotl; using :: ilogbl; using :: lgammal;
using :: log1pl; using :: log2l; using :: logbl;
using :: llrintl; using :: lrintl; using :: nearbyintl;
using :: rintl; using :: llroundl; using :: lroundl;
using :: fdiml; using :: fmal; using :: fmaxl; using :: fminl;
using :: roundl; using :: truncl;
using :: remainderl; using :: remquol;
using :: copysignl; using :: nanl;
using :: nextafterl; using :: scalbnl; using :: scalblnl;
using :: nexttowardl; using :: tgammal;

using :: fpclassify; using :: signbit;
using :: isfinite; using :: isinf;
using :: isnan; using :: isnormal;
using :: isgreater; using :: isgreaterequal;
using :: isless; using :: islessequal;
using :: islessgreater; using :: isunordered;
}







 
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\limits"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\cwchar"

#pragma once




#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\wchar.h"









#pragma once


#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_memcpy_s.h"







#pragma once

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\errno.h"







#pragma once




__pragma(pack(push, 8)) extern "C" {



 extern int* __cdecl _errno(void);


 errno_t __cdecl _set_errno( int _Value);
 errno_t __cdecl _get_errno( int* _Value);



 unsigned long* __cdecl __doserrno(void);


 errno_t __cdecl _set_doserrno( unsigned long _Value);
 errno_t __cdecl _get_doserrno( unsigned long * _Value);




#line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\errno.h"


#line 78 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\errno.h"





#line 126 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\errno.h"



} __pragma(pack(pop))
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_memcpy_s.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime_string.h"







#pragma once

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h"




























#line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime.h"

#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\vcruntime_string.h"



__pragma(pack(push, 8)) extern "C" {




 void const* __cdecl memchr(
     void const* _Buf,
                                int         _Val,
                                size_t      _MaxCount
    );


int __cdecl memcmp(
     void const* _Buf1,
     void const* _Buf2,
                        size_t      _Size
    );









void* __cdecl memcpy(
     void* _Dst,
           void const* _Src,
                              size_t      _Size
    );


 void* __cdecl memmove(
     void*       _Dst,
           void const* _Src,
                                  size_t      _Size
    );








void* __cdecl memset(
     void*  _Dst,
                              int    _Val,
                              size_t _Size
    );


 char const* __cdecl strchr(
     char const* _Str,
       int         _Val
    );


 char const* __cdecl strrchr(
     char const* _Str,
       int         _Ch
    );

 
 char const* __cdecl strstr(
     char const* _Str,
     char const* _SubStr
    );



 wchar_t const* __cdecl wcschr(
     wchar_t const* _Str,
       wchar_t        _Ch
    );


 wchar_t const* __cdecl wcsrchr(
     wchar_t const* _Str,
       wchar_t        _Ch
    );

 

 wchar_t const* __cdecl wcsstr(
     wchar_t const* _Str,
     wchar_t const* _SubStr
    );



} __pragma(pack(pop))

#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_memcpy_s.h"

__pragma(pack(push, 8)) extern "C" {





#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_memcpy_s.h"



    
    
    static __inline errno_t __cdecl memcpy_s(
         void*       const _Destination,
                                                             rsize_t     const _DestinationSize,
                                void const* const _Source,
                                                             rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        if (_Source == 0 || _DestinationSize < _SourceSize)
        {
            memset(_Destination, 0, _DestinationSize);

            { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
            { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

            
            return 22;
        }

        memcpy(_Destination, _Source, _SourceSize);
        return 0;
    }

    
    static __inline errno_t __cdecl memmove_s(
         void*       const _Destination,
                                                             rsize_t     const _DestinationSize,
                                void const* const _Source,
                                                             rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

        memmove(_Destination, _Source, _SourceSize);
        return 0;
    }





} __pragma(pack(pop))
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_wconio.h"








#pragma once

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_stdio_config.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {


#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_stdio_config.h"

#line 31 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_stdio_config.h"














#line 60 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_stdio_config.h"





        #pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")












 
__declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_printf_options(void)
{
    static unsigned __int64 _OptionsStorage;
    return &_OptionsStorage;
}



 
__declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_scanf_options(void)
{
    static unsigned __int64 _OptionsStorage;
    return &_OptionsStorage;
}























} __pragma(pack(pop))

#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_wconio.h"

__pragma(pack(push, 8)) extern "C" {









    
    
     errno_t __cdecl _cgetws_s(
         wchar_t* _Buffer,
                                              size_t   _BufferCount,
                                             size_t*  _SizeRead
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _cgetws_s(wchar_t (&_Buffer)[_Size], size_t* _SizeRead) throw() { return _cgetws_s(_Buffer, _Size, _SizeRead); } }






    
     int __cdecl _cputws(
         wchar_t const* _Buffer
        );

          wint_t __cdecl _getwch  (void);
          wint_t __cdecl _getwche (void);
      wint_t __cdecl _putwch  ( wchar_t _Character);
      wint_t __cdecl _ungetwch( wint_t  _Character);

          wint_t __cdecl _getwch_nolock  (void);
          wint_t __cdecl _getwche_nolock (void);
      wint_t __cdecl _putwch_nolock  ( wchar_t _Character);
      wint_t __cdecl _ungetwch_nolock( wint_t  _Character);



    
    
    
    
    
    
     int __cdecl __conio_common_vcwprintf(
                                            unsigned __int64 _Options,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
     int __cdecl __conio_common_vcwprintf_s(
                                            unsigned __int64 _Options,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
     int __cdecl __conio_common_vcwprintf_p(
                                            unsigned __int64 _Options,
          wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vcwprintf_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )



    {
        return __conio_common_vcwprintf((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }


    
    __inline int __cdecl _vcwprintf(
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )



    {
        return _vcwprintf_l(_Format, 0, _ArgList);
    }


    
    __inline int __cdecl _vcwprintf_s_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )



    {
        return __conio_common_vcwprintf_s((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }


    
    __inline int __cdecl _vcwprintf_s(
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )



    {
        return _vcwprintf_s_l(_Format, 0, _ArgList);
    }


    
    __inline int __cdecl _vcwprintf_p_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
        )



    {
        return __conio_common_vcwprintf_p((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }


    
    __inline int __cdecl _vcwprintf_p(
          const wchar_t* const _Format,
                                      va_list              _ArgList
        )



    {
        return _vcwprintf_p_l(_Format, 0, _ArgList);
    }


    
    __inline int __cdecl _cwprintf_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


    
    __inline int __cdecl _cwprintf(
          wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


    
    __inline int __cdecl _cwprintf_s_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


    
    __inline int __cdecl _cwprintf_s(
          wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


    
    __inline int __cdecl _cwprintf_p_l(
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


    
    __inline int __cdecl _cwprintf_p(
          wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }




    
    
    
    
    
    
     int __cdecl __conio_common_vcwscanf(
                                           unsigned __int64 _Options,
          wchar_t const*   _Format,
                                       _locale_t        _Locale,
                                               va_list          _ArgList
        );

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf_l(
          wchar_t const* const _Format,
                                       _locale_t      const _Locale,
                                               va_list              _ArgList
        )



    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()),
            _Format, _Locale, _ArgList);
    }


     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf(
          wchar_t const* const _Format,
                                               va_list              _ArgList
        )



    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vcwscanf_l(_Format, 0, _ArgList);
        #pragma warning(pop)
    }


    
    __inline int __cdecl _vcwscanf_s_l(
          wchar_t const* const _Format,
                                       _locale_t      const _Locale,
                                               va_list              _ArgList
        )



    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Format, _Locale, _ArgList);
    }


    
    __inline int __cdecl _vcwscanf_s(
          wchar_t const* const _Format,
                                               va_list              _ArgList
        )



    {
        return _vcwscanf_s_l(_Format, 0, _ArgList);
    }


     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf_l(
          wchar_t const* const _Format,
                                       _locale_t      const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vcwscanf_l(_Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf(
          wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vcwscanf_l(_Format, 0, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


    
    __inline int __cdecl _cwscanf_s_l(
          wchar_t const* const _Format,
                                       _locale_t      const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwscanf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


    
    __inline int __cdecl _cwscanf_s(
          wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwscanf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }






} __pragma(pack(pop))
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_wctype.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {

















     const unsigned short* __cdecl __pctype_func(void);
     const wctype_t*       __cdecl __pwctype_func(void);

#line 42 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_wctype.h"


#line 52 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_wctype.h"











  int __cdecl iswalnum  ( wint_t _C);
  int __cdecl iswalpha  ( wint_t _C);
  int __cdecl iswascii  ( wint_t _C);
  int __cdecl iswblank  ( wint_t _C);
  int __cdecl iswcntrl  ( wint_t _C);


  int __cdecl iswdigit  ( wint_t _C);

  int __cdecl iswgraph  ( wint_t _C);
  int __cdecl iswlower  ( wint_t _C);
  int __cdecl iswprint  ( wint_t _C);
  int __cdecl iswpunct  ( wint_t _C);
  int __cdecl iswspace  ( wint_t _C);
  int __cdecl iswupper  ( wint_t _C);
  int __cdecl iswxdigit ( wint_t _C);
  int __cdecl __iswcsymf( wint_t _C);
  int __cdecl __iswcsym ( wint_t _C);

  int __cdecl _iswalnum_l ( wint_t _C,  _locale_t _Locale);
  int __cdecl _iswalpha_l ( wint_t _C,  _locale_t _Locale);
  int __cdecl _iswblank_l ( wint_t _C,  _locale_t _Locale);
  int __cdecl _iswcntrl_l ( wint_t _C,  _locale_t _Locale);
  int __cdecl _iswdigit_l ( wint_t _C,  _locale_t _Locale);
  int __cdecl _iswgraph_l ( wint_t _C,  _locale_t _Locale);
  int __cdecl _iswlower_l ( wint_t _C,  _locale_t _Locale);
  int __cdecl _iswprint_l ( wint_t _C,  _locale_t _Locale);
  int __cdecl _iswpunct_l ( wint_t _C,  _locale_t _Locale);
  int __cdecl _iswspace_l ( wint_t _C,  _locale_t _Locale);
  int __cdecl _iswupper_l ( wint_t _C,  _locale_t _Locale);
  int __cdecl _iswxdigit_l( wint_t _C,  _locale_t _Locale);
  int __cdecl _iswcsymf_l ( wint_t _C,  _locale_t _Locale);
  int __cdecl _iswcsym_l  ( wint_t _C,  _locale_t _Locale);


  wint_t __cdecl towupper( wint_t _C);
  wint_t __cdecl towlower( wint_t _C);
  int    __cdecl iswctype( wint_t _C,  wctype_t _Type);

  wint_t __cdecl _towupper_l( wint_t _C,  _locale_t _Locale);
  wint_t __cdecl _towlower_l( wint_t _C,  _locale_t _Locale);
  int    __cdecl _iswctype_l( wint_t _C,  wctype_t _Type,  _locale_t _Locale);



      int __cdecl isleadbyte( int _C);
      int __cdecl _isleadbyte_l( int _C,  _locale_t _Locale);

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "iswctype" " " "instead. See online help for details."))  int __cdecl is_wctype( wint_t _C,  wctype_t _Type);









#line 196 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_wctype.h"



} __pragma(pack(pop))
#line 17 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_wdirect.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {







 
  wchar_t* __cdecl _wgetcwd(
     wchar_t* _DstBuf,
                                 int      _SizeInWords
    );


 
  wchar_t* __cdecl _wgetdcwd(
                                 int      _Drive,
     wchar_t* _DstBuf,
                                 int      _SizeInWords
    );







 int __cdecl _wchdir(
     wchar_t const* _Path
    );


 int __cdecl _wmkdir(
     wchar_t const* _Path
    );


 int __cdecl _wrmdir(
     wchar_t const* _Path
    );



} __pragma(pack(pop))
#line 18 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_wio.h"








#pragma once

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_share.h"








#pragma once











#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_wio.h"

__pragma(pack(push, 8)) extern "C" {



#pragma warning(push)
#pragma warning(disable:4820)  








#line 35 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_wio.h"

typedef unsigned long _fsize_t;

struct _wfinddata32_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata32i64_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    __int64    size;
    wchar_t    name[260];
};

struct _wfinddata64i32_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata64_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    __int64    size;
    wchar_t    name[260];
};








#line 96 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_wio.h"


 int __cdecl _waccess(
     wchar_t const* _FileName,
       int            _AccessMode
    );


 errno_t __cdecl _waccess_s(
     wchar_t const* _FileName,
       int            _AccessMode
    );


 int __cdecl _wchmod(
     wchar_t const* _FileName,
       int            _Mode
    );

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 int __cdecl _wcreat(
     wchar_t const* _FileName,
       int            _PermissionMode
    );



 intptr_t __cdecl _wfindfirst32(
     wchar_t const*         _FileName,
      struct _wfinddata32_t* _FindData
    );



 int __cdecl _wfindnext32(
      intptr_t               _FindHandle,
     struct _wfinddata32_t* _FindData
    );

 int __cdecl _wunlink(
     wchar_t const* _FileName
    );


 int __cdecl _wrename(
     wchar_t const* _OldFileName,
     wchar_t const* _NewFileName
    );

 errno_t __cdecl _wmktemp_s(
     wchar_t* _TemplateName,
                                size_t   _SizeInWords
    );




extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmktemp_s(wchar_t (&_TemplateName)[_Size]) throw() { return _wmktemp_s(_TemplateName, _Size); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmktemp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) wchar_t* __cdecl _wmktemp( wchar_t *_TemplateName);



 intptr_t __cdecl _wfindfirst32i64(
     wchar_t const*            _FileName,
      struct _wfinddata32i64_t* _FindData
    );



 intptr_t __cdecl _wfindfirst64i32(
     wchar_t const*            _FileName,
      struct _wfinddata64i32_t* _FindData
    );



 intptr_t __cdecl _wfindfirst64(
     wchar_t const*         _FileName,
      struct _wfinddata64_t* _FindData
    );



 int __cdecl _wfindnext32i64(
      intptr_t                  _FindHandle,
     struct _wfinddata32i64_t* _FindData
    );



 int __cdecl _wfindnext64i32(
      intptr_t                  _FindHandle,
     struct _wfinddata64i32_t* _FindData
    );



 int __cdecl _wfindnext64(
      intptr_t               _FindHandle,
     struct _wfinddata64_t* _FindData
    );


 errno_t __cdecl _wsopen_s(
      int*           _FileHandle,
     wchar_t const* _FileName,
       int            _OpenFlag,
       int            _ShareFlag,
       int            _PermissionFlag
    );

 errno_t __cdecl _wsopen_dispatch(
     wchar_t const* _FileName,
       int            _OFlag,
       int            _ShFlag,
       int            _PMode,
      int*           _PFileHandle,
       int            _BSecure
    );





    
    extern "C++"  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wopen(
         wchar_t const* _FileName,
           int            _OFlag,
           int            _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, 0x40, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

    extern "C++"  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wsopen(
         wchar_t const* _FileName,
           int            _OFlag,
           int            _ShFlag,
           int            _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }


#line 270 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_wio.h"



#pragma warning(pop)



} __pragma(pack(pop))
#line 19 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_wprocess.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {


    


     intptr_t __cdecl _wexecl(
         wchar_t const* _FileName,
         wchar_t const* _ArgList,
        ...);

     intptr_t __cdecl _wexecle(
         wchar_t const* _FileName,
         wchar_t const* _ArgList,
        ...);

     intptr_t __cdecl _wexeclp(
         wchar_t const* _FileName,
         wchar_t const* _ArgList,
        ...);

     intptr_t __cdecl _wexeclpe(
         wchar_t const* _FileName,
         wchar_t const* _ArgList,
        ...);

     intptr_t __cdecl _wexecv(
         wchar_t const*        _FileName,
         wchar_t const* const* _ArgList
        );

     intptr_t __cdecl _wexecve(
             wchar_t const*        _FileName,
             wchar_t const* const* _ArgList,
         wchar_t const* const* _Env
        );

     intptr_t __cdecl _wexecvp(
         wchar_t const*        _FileName,
         wchar_t const* const* _ArgList
        );

     intptr_t __cdecl _wexecvpe(
             wchar_t const*        _FileName,
             wchar_t const* const* _ArgList,
         wchar_t const* const* _Env
        );

     intptr_t __cdecl _wspawnl(
           int            _Mode,
         wchar_t const* _FileName,
         wchar_t const* _ArgList,
        ...);

     intptr_t __cdecl _wspawnle(
           int            _Mode,
         wchar_t const* _FileName,
         wchar_t const* _ArgList,
        ...);

     intptr_t __cdecl _wspawnlp(
           int            _Mode,
         wchar_t const* _FileName,
         wchar_t const* _ArgList,
        ...);

     intptr_t __cdecl _wspawnlpe(
           int            _Mode,
         wchar_t const* _FileName,
         wchar_t const* _ArgList,
        ...);

     intptr_t __cdecl _wspawnv(
           int                   _Mode,
         wchar_t const*        _FileName,
         wchar_t const* const* _ArgList
        );

     intptr_t __cdecl _wspawnve(
               int                   _Mode,
             wchar_t const*        _FileName,
             wchar_t const* const* _ArgList,
         wchar_t const* const* _Env
        );

     intptr_t __cdecl _wspawnvp(
           int                   _Mode,
         wchar_t const*        _FileName,
         wchar_t const* const* _ArgList
        );

     intptr_t __cdecl _wspawnvpe(
               int                   _Mode,
             wchar_t const*        _FileName,
             wchar_t const* const* _ArgList,
         wchar_t const* const* _Env
        );

     int __cdecl _wsystem(
         wchar_t const* _Command
        );





} __pragma(pack(pop))
#line 20 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_wstdio.h"









#pragma once




__pragma(pack(push, 8)) extern "C" {









    typedef struct _iobuf
    {
        void* _Placeholder;
    } FILE;


 FILE* __cdecl __acrt_iob_func(unsigned);















 wint_t __cdecl fgetwc(
     FILE* _Stream
    );


 wint_t __cdecl _fgetwchar(void);


 wint_t __cdecl fputwc(
        wchar_t _Character,
     FILE*   _Stream);


 wint_t __cdecl _fputwchar(
     wchar_t _Character
    );


 wint_t __cdecl getwc(
     FILE* _Stream
    );


 wint_t __cdecl getwchar(void);




 wchar_t* __cdecl fgetws(
     wchar_t* _Buffer,
                             int      _BufferCount,
                          FILE*    _Stream
    );


 int __cdecl fputws(
      wchar_t const* _Buffer,
     FILE*          _Stream
    );



 wchar_t* __cdecl _getws_s(
     wchar_t* _Buffer,
                             size_t   _BufferCount
    );





extern "C++" { template <size_t _Size> inline wchar_t* __cdecl _getws_s(wchar_t (&_Buffer)[_Size]) throw() { return _getws_s(_Buffer, _Size); } }


 wint_t __cdecl putwc(
        wchar_t _Character,
     FILE*   _Stream
    );


 wint_t __cdecl putwchar(
     wchar_t _Character
    );


 int __cdecl _putws(
     wchar_t const* _Buffer
    );


 wint_t __cdecl ungetwc(
        wint_t _Character,
     FILE*  _Stream
    );


 FILE * __cdecl _wfdopen(
       int            _FileHandle,
     wchar_t const* _Mode
    );

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 FILE* __cdecl _wfopen(
     wchar_t const* _FileName,
     wchar_t const* _Mode
    );


 errno_t __cdecl _wfopen_s(
     FILE**         _Stream,
                        wchar_t const* _FileName,
                        wchar_t const* _Mode
    );


__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfreopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 FILE* __cdecl _wfreopen(
      wchar_t const* _FileName,
      wchar_t const* _Mode,
     FILE*          _OldStream
    );


 errno_t __cdecl _wfreopen_s(
     FILE**         _Stream,
                        wchar_t const* _FileName,
                        wchar_t const* _Mode,
                       FILE*          _OldStream
    );


 FILE* __cdecl _wfsopen(
     wchar_t const* _FileName,
     wchar_t const* _Mode,
       int            _ShFlag
    );

 void __cdecl _wperror(
     wchar_t const* _ErrorMessage
    );



    
     FILE* __cdecl _wpopen(
         wchar_t const* _Command,
         wchar_t const* _Mode
        );



 int __cdecl _wremove(
     wchar_t const* _FileName
    );





  wchar_t* __cdecl _wtempnam(
     wchar_t const* _Directory,
     wchar_t const* _FilePrefix
    );





 errno_t __cdecl _wtmpnam_s(
     wchar_t* _Buffer,
                             size_t   _BufferCount
    );




extern "C++" { template <size_t _Size> inline errno_t __cdecl _wtmpnam_s(wchar_t (&_Buffer)[_Size]) throw() { return _wtmpnam_s(_Buffer, _Size); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wtmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) wchar_t* __cdecl _wtmpnam( wchar_t *_Buffer);









 wint_t __cdecl _fgetwc_nolock(
     FILE* _Stream
    );


 wint_t __cdecl _fputwc_nolock(
        wchar_t _Character, 
     FILE*   _Stream
    );


 wint_t __cdecl _getwc_nolock(
     FILE* _Stream
    );


 wint_t __cdecl _putwc_nolock(
        wchar_t _Character,
     FILE*   _Stream
    );


 wint_t __cdecl _ungetwc_nolock(
        wint_t _Character,
     FILE*  _Stream
    );






















 int __cdecl __stdio_common_vfwprintf(
                                        unsigned __int64 _Options,
                                     FILE*            _Stream,
      wchar_t const*   _Format,
                                    _locale_t        _Locale,
                                            va_list          _ArgList
    );


 int __cdecl __stdio_common_vfwprintf_s(
                                        unsigned __int64 _Options,
                                     FILE*            _Stream,
      wchar_t const*   _Format,
                                    _locale_t        _Locale,
                                            va_list          _ArgList
    );


 int __cdecl __stdio_common_vfwprintf_p(
                                        unsigned __int64 _Options,
                                     FILE*            _Stream,
      wchar_t const*   _Format,
                                    _locale_t        _Locale,
                                            va_list          _ArgList
    );


__inline int __cdecl _vfwprintf_l(
                                     FILE*          const _Stream,
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
                                            va_list              _ArgList
    )



{
    return __stdio_common_vfwprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
}



__inline int __cdecl vfwprintf(
                           FILE*          const _Stream,
      wchar_t const* const _Format,
                                  va_list              _ArgList
    )



{
    return _vfwprintf_l(_Stream, _Format, 0, _ArgList);
}



__inline int __cdecl _vfwprintf_s_l(
                                     FILE*          const _Stream,
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
                                            va_list              _ArgList
    )



{
    return __stdio_common_vfwprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
}




    
    __inline int __cdecl vfwprintf_s(
                               FILE*          const _Stream,
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )



    {
        return _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
    }





__inline int __cdecl _vfwprintf_p_l(
                                     FILE*          const _Stream,
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
                                            va_list              _ArgList
    )



{
    return __stdio_common_vfwprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
}



__inline int __cdecl _vfwprintf_p(
                           FILE*          const _Stream,
      wchar_t const* const _Format,
                                  va_list              _ArgList
    )



{
    return _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
}



__inline int __cdecl _vwprintf_l(
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
                                            va_list              _ArgList
    )



{
    return _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
}



__inline int __cdecl vwprintf(
      wchar_t const* const _Format,
                                  va_list              _ArgList
    )



{
    return _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
}



__inline int __cdecl _vwprintf_s_l(
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
                                            va_list              _ArgList
    )



{
    return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
}




    
    __inline int __cdecl vwprintf_s(
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )



    {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }





__inline int __cdecl _vwprintf_p_l(
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
                                            va_list              _ArgList
    )



{
    return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
}



__inline int __cdecl _vwprintf_p(
      wchar_t const* const _Format,
                                  va_list              _ArgList
    )



{
    return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
}



__inline int __cdecl _fwprintf_l(
                                     FILE*          const _Stream,
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
    _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl fwprintf(
                           FILE*          const _Stream,
      wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
    _Result = _vfwprintf_l(_Stream, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _fwprintf_s_l(
                                     FILE*          const _Stream,
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
    _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




    
    __inline int __cdecl fwprintf_s(
                               FILE*          const _Stream,
          wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }





__inline int __cdecl _fwprintf_p_l(
                                     FILE*          const _Stream,
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
    _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _fwprintf_p(
                           FILE*          const _Stream,
      wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
    _Result = _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _wprintf_l(
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
    _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl wprintf(
      wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
    _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _wprintf_s_l(
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
    _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




    
    __inline int __cdecl wprintf_s(
          wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }





__inline int __cdecl _wprintf_p_l(
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
    _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _wprintf_p(
      wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
    _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}









 int __cdecl __stdio_common_vfwscanf(
                                       unsigned __int64 _Options,
                                    FILE*            _Stream,
      wchar_t const*   _Format,
                                   _locale_t        _Locale,
                                           va_list          _ArgList
    );


__inline int __cdecl _vfwscanf_l(
     FILE*                                const _Stream,
      wchar_t const* const _Format,
                          _locale_t      const _Locale,
                                  va_list              _ArgList
    )



{
    return __stdio_common_vfwscanf(
        (*__local_stdio_scanf_options ()),
        _Stream, _Format, _Locale, _ArgList);
}



__inline int __cdecl vfwscanf(
     FILE*                                const _Stream,
      wchar_t const* const _Format,
                                  va_list              _ArgList
    )



{
    return _vfwscanf_l(_Stream, _Format, 0, _ArgList);
}



__inline int __cdecl _vfwscanf_s_l(
                           FILE*          const _Stream,
      wchar_t const* const _Format,
                          _locale_t      const _Locale,
                                  va_list              _ArgList
    )



{
    return __stdio_common_vfwscanf(
        (*__local_stdio_scanf_options ()) | (1ULL << 0),
        _Stream, _Format, _Locale, _ArgList);
}




    
    __inline int __cdecl vfwscanf_s(
                               FILE*          const _Stream,
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )



    {
        return _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
    }




__inline int __cdecl _vwscanf_l(
      wchar_t const* const _Format,
                          _locale_t      const _Locale,
                                  va_list              _ArgList
    )



{
    return _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
}



__inline int __cdecl vwscanf(
      wchar_t const* const _Format,
                                  va_list              _ArgList
    )



{
    return _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
}



__inline int __cdecl _vwscanf_s_l(
      wchar_t const* const _Format,
                          _locale_t      const _Locale,
                                  va_list              _ArgList
    )



{
    return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
}




    
    __inline int __cdecl vwscanf_s(
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )



    {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }




 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _fwscanf_l(
                                    FILE*          const _Stream,
      wchar_t const* const _Format,
                                   _locale_t      const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
    _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}


 __declspec(deprecated("This function or variable may be unsafe. Consider using " "fwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl fwscanf(
                          FILE*          const _Stream,
      wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
    _Result = _vfwscanf_l(_Stream, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _fwscanf_s_l(
                                      FILE*          const _Stream,
      wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
    _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




    
    __inline int __cdecl fwscanf_s(
                                FILE*          const _Stream,
          wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }




 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _wscanf_l(
      wchar_t const* const _Format,
                                   _locale_t      const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
    _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}


 __declspec(deprecated("This function or variable may be unsafe. Consider using " "wscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl wscanf(
      wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
    _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



__inline int __cdecl _wscanf_s_l(
      wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
    _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




    
    __inline int __cdecl wscanf_s(
          wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }











#line 998 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_wstdio.h"



 int __cdecl __stdio_common_vswprintf(
                                        unsigned __int64 _Options,
                wchar_t*         _Buffer,
                                        size_t           _BufferCount,
      wchar_t const*   _Format,
                                    _locale_t        _Locale,
                                            va_list          _ArgList
    );



 int __cdecl __stdio_common_vswprintf_s(
                                        unsigned __int64 _Options,
                wchar_t*         _Buffer,
                                        size_t           _BufferCount,
      wchar_t const*   _Format,
                                    _locale_t        _Locale,
                                            va_list          _ArgList
    );



 int __cdecl __stdio_common_vsnwprintf_s(
                                        unsigned __int64 _Options,
                wchar_t*         _Buffer,
                                        size_t           _BufferCount,
                                        size_t           _MaxCount,
      wchar_t const*   _Format,
                                    _locale_t        _Locale,
                                            va_list          _ArgList
    );



 int __cdecl __stdio_common_vswprintf_p(
                                        unsigned __int64 _Options,
                wchar_t*         _Buffer,
                                        size_t           _BufferCount,
      wchar_t const*   _Format,
                                    _locale_t        _Locale,
                                            va_list          _ArgList
    );


 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _vsnwprintf_l(
         wchar_t*       const _Buffer,
                                            size_t         const _BufferCount,
          wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                                va_list              _ArgList
    )



{
    int const _Result = __stdio_common_vswprintf(
        (*__local_stdio_printf_options()) | (1ULL << 0),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}


#pragma warning(push)
#pragma warning(disable: 4793)



__inline int __cdecl _vsnwprintf_s_l(
                wchar_t*       const _Buffer,
                                        size_t         const _BufferCount,
                                        size_t         const _MaxCount,
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
                                            va_list              _ArgList
    )



{
    int const _Result = __stdio_common_vsnwprintf_s(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}




__inline int __cdecl _vsnwprintf_s(
      wchar_t*       const _Buffer,
                              size_t         const _BufferCount,
                              size_t         const _MaxCount,
      wchar_t const* const _Format,
                                  va_list              _ArgList
    )



{
    return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
}









__declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl _snwprintf( wchar_t *_Buffer, size_t _BufferCount, wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl _vsnwprintf( wchar_t *_Buffer, size_t _BufferCount, wchar_t const* _Format, va_list _Args);

#pragma warning(pop)


 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _vsnwprintf(
      wchar_t*       _Buffer,
                                         size_t         _BufferCount,
                 wchar_t const* _Format,
                                             va_list        _ArgList
    )



{
    #pragma warning(push)
    #pragma warning(disable: 4996) 
    return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    #pragma warning(pop)
}









extern "C++" { template <size_t _Size> inline int __cdecl _vsnwprintf_s(wchar_t (&_Buffer)[_Size], size_t _BufferCount, wchar_t const* _Format, va_list _ArgList) throw() { return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }



__inline int __cdecl _vswprintf_c_l(
                wchar_t*       const _Buffer,
                                        size_t         const _BufferCount,
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
                                            va_list              _ArgList
    )



{
    int const _Result = __stdio_common_vswprintf(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}




__inline int __cdecl _vswprintf_c(
      wchar_t*       const _Buffer,
                              size_t         const _BufferCount,
      wchar_t const* const _Format,
                                  va_list              _ArgList
    )



{
    return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
}




__inline int __cdecl _vswprintf_l(
                       wchar_t*       const _Buffer,
                                        size_t         const _BufferCount,
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
                                            va_list              _ArgList
    )



{
    #pragma warning(push)
    #pragma warning(disable: 4996) 
    return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    #pragma warning(pop)
}




__inline int __cdecl __vswprintf_l(
                       wchar_t*       const _Buffer,
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
                                            va_list              _ArgList
    )



{
    return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
}




__inline int __cdecl _vswprintf(
             wchar_t*       const _Buffer,
      wchar_t const* const _Format,
                                  va_list              _ArgList
    )



{
    return _vswprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
}




__inline int __cdecl vswprintf(
                       wchar_t*       const _Buffer,
                                        size_t         const _BufferCount,
      wchar_t const* const _Format,
                                            va_list              _ArgList
    )



{
    return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
}




__inline int __cdecl _vswprintf_s_l(
                wchar_t*       const _Buffer,
                                        size_t         const _BufferCount,
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
                                            va_list              _ArgList
    )



{
    int const _Result = __stdio_common_vswprintf_s(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}




    
    __inline int __cdecl vswprintf_s(
          wchar_t*       const _Buffer,
                                  size_t         const _BufferCount,
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )



    {
        return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }










extern "C++" { template <size_t _Size> inline int __cdecl vswprintf_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Format, va_list _ArgList) throw() { return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } }



__inline int __cdecl _vswprintf_p_l(
                wchar_t*       const _Buffer,
                                        size_t         const _BufferCount,
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
                                            va_list              _ArgList
    )



{
    int const _Result = __stdio_common_vswprintf_p(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}




__inline int __cdecl _vswprintf_p(
      wchar_t*       const _Buffer,
                              size_t         const _BufferCount,
      wchar_t const* const _Format,
                                  va_list              _ArgList
    )



{
    return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
}




__inline int __cdecl _vscwprintf_l(
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
                                            va_list              _ArgList
    )



{
    int const _Result = __stdio_common_vswprintf(
        (*__local_stdio_printf_options()) | (1ULL << 1),
        0, 0, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}




__inline int __cdecl _vscwprintf(
      wchar_t const* const _Format,
                                  va_list              _ArgList
    )



{
    return _vscwprintf_l(_Format, 0, _ArgList);
}




__inline int __cdecl _vscwprintf_p_l(
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
                                            va_list              _ArgList
    )



{
    int const _Result = __stdio_common_vswprintf_p(
        (*__local_stdio_printf_options()) | (1ULL << 1),
        0, 0, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}




__inline int __cdecl _vscwprintf_p(
      wchar_t const* const _Format, 
                                  va_list              _ArgList
    )



{
    return _vscwprintf_p_l(_Format, 0, _ArgList);
}




__inline int __cdecl __swprintf_l(
                       wchar_t*       const _Buffer,
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
    _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _swprintf_l(
                       wchar_t*       const _Buffer,
                                        size_t         const _BufferCount,
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
    _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _swprintf(
             wchar_t*       const _Buffer,
      wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
    _Result = __vswprintf_l(_Buffer, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl swprintf(
             wchar_t*       const _Buffer,
                              size_t         const _BufferCount,
      wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
    _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}


#pragma warning(push)


#pragma warning(disable:4793 4996)








__declspec(deprecated("This function or variable may be unsafe. Consider using " "__swprintf_l_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl __swprintf_l( wchar_t *_Buffer, wchar_t const* _Format, _locale_t _Locale, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl __vswprintf_l( wchar_t *_Buffer, wchar_t const* _Format, _locale_t _Locale, va_list _Args);






__declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl _swprintf( wchar_t *_Buffer, wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline int __cdecl _vswprintf( wchar_t *_Buffer, wchar_t const* _Format, va_list _Args);

#pragma warning(pop)



__inline int __cdecl _swprintf_s_l(
                wchar_t*       const _Buffer,
                                        size_t         const _BufferCount,
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
    _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




    
    __inline int __cdecl swprintf_s(
          wchar_t*       const _Buffer,
                                  size_t         const _BufferCount,
          wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }









extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl swprintf_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } __pragma(warning(pop)); }



__inline int __cdecl _swprintf_p_l(
                wchar_t*       const _Buffer,
                                        size_t         const _BufferCount,
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
    _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _swprintf_p(
      wchar_t*       const _Buffer,
                              size_t         const _BufferCount,
      wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
    _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _swprintf_c_l(
                wchar_t*       const _Buffer,
                                        size_t         const _BufferCount,
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
    _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _swprintf_c(
      wchar_t*       const _Buffer,
                              size_t         const _BufferCount,
      wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
    _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _snwprintf_l(
      wchar_t*       const _Buffer,
                                         size_t         const _BufferCount,
       wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

    #pragma warning(push)
    #pragma warning(disable: 4996) 
    _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    #pragma warning(pop)

    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _snwprintf(
      wchar_t*       _Buffer,
                                         size_t         _BufferCount,
                 wchar_t const* _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

    #pragma warning(push)
    #pragma warning(disable: 4996) 
    _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    #pragma warning(pop)

    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _snwprintf_s_l(
                wchar_t*       const _Buffer,
                                        size_t         const _BufferCount,
                                        size_t         const _MaxCount,
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
    _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _snwprintf_s(
      wchar_t*       const _Buffer,
                              size_t         const _BufferCount,
                              size_t         const _MaxCount,
      wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
    _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}








extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl _snwprintf_s(wchar_t (&_Buffer)[_Size], size_t _BufferCount, wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } __pragma(warning(pop)); }


__inline int __cdecl _scwprintf_l(
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
    _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _scwprintf(
      wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
    _Result = _vscwprintf_l(_Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _scwprintf_p_l(
      wchar_t const* const _Format,
                                    _locale_t      const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
    _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _scwprintf_p(
      wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
    _Result = _vscwprintf_p_l(_Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




    #pragma warning(push)
    #pragma warning(disable: 4141 4412 4793 4996 6054)



        extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        inline int swprintf(
                     wchar_t*       const _Buffer,
              wchar_t const* const _Format,
            ...) throw()
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            #pragma warning(suppress: 28719)
            _Result = vswprintf(_Buffer, 2147483647, _Format, _ArgList);       
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }

        extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        inline int __cdecl vswprintf(
                     wchar_t*       const _Buffer,
              wchar_t const* const _Format,
                                          va_list              _ArgList
            ) throw()
        {
            #pragma warning(suppress: 28719)
            return vswprintf(_Buffer, 2147483647, _Format, _ArgList);
        }

        extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        inline int _swprintf_l(
                               wchar_t*       const _Buffer,
              wchar_t const* const _Format,
                                            _locale_t      const _Locale,
            ...) throw()
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
            _Result = _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }

        extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        inline int __cdecl _vswprintf_l(
                               wchar_t*       const _Buffer,
              wchar_t const* const _Format,
                                            _locale_t      const _Locale,
                                                    va_list              _ArgList
            ) throw()
        {
            return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
        }



    #pragma warning(pop)


#line 1882 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_wstdio.h"








 int __cdecl __stdio_common_vswscanf(
                                       unsigned __int64 _Options,
            wchar_t const*   _Buffer,
                                       size_t           _BufferCount,
      wchar_t const*   _Format,
                                   _locale_t        _Locale,
                                           va_list          _ArgList
    );



__inline int __cdecl _vswscanf_l(
                            wchar_t const* const _Buffer,
      wchar_t const* const _Format,
                          _locale_t      const _Locale,
                                  va_list              _ArgList
    )



{
    return __stdio_common_vswscanf(
        (*__local_stdio_scanf_options ()),
        _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
}




__inline int __cdecl vswscanf(
                            wchar_t const* _Buffer,
      wchar_t const* _Format,
                                  va_list        _ArgList
    )



{
    return _vswscanf_l(_Buffer, _Format, 0, _ArgList);
}




__inline int __cdecl _vswscanf_s_l(
                            wchar_t const* const _Buffer,
      wchar_t const* const _Format,
                          _locale_t      const _Locale,
                                  va_list              _ArgList
    )



{
    return __stdio_common_vswscanf(
        (*__local_stdio_scanf_options ()) | (1ULL << 0),
        _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
}




    
    
    __inline int __cdecl vswscanf_s(
                                wchar_t const* const _Buffer,
          wchar_t const* const _Format,
                                      va_list              _ArgList
        )



    {
        return _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
    }










extern "C++" { template <size_t _Size> inline int __cdecl vswscanf_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Format, va_list _Args) throw() { return vswscanf_s(_Buffer, _Size, _Format, _Args); } }


 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _vsnwscanf_l(
            wchar_t const* const _Buffer,
                                       size_t         const _BufferCount,
      wchar_t const* const _Format,
                                   _locale_t      const _Locale,
                                           va_list              _ArgList
    )



{
    return __stdio_common_vswscanf(
        (*__local_stdio_scanf_options ()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);
}




__inline int __cdecl _vsnwscanf_s_l(
              wchar_t const* const _Buffer,
                                         size_t         const _BufferCount,
      wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                             va_list              _ArgList
    )



{
    return __stdio_common_vswscanf(
        (*__local_stdio_scanf_options ()) | (1ULL << 0),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);
}



 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _swscanf_l(
                                     wchar_t const* const _Buffer,
      wchar_t const* const _Format,
                                   _locale_t            _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
    _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}



 __declspec(deprecated("This function or variable may be unsafe. Consider using " "swscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl swscanf(
                           wchar_t const* const _Buffer,
      wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
    _Result = _vswscanf_l(_Buffer, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _swscanf_s_l(
                                       wchar_t const* const _Buffer,
      wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
    _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




    
    
    __inline int __cdecl swscanf_s(
                                 wchar_t const* const _Buffer,
          wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);  
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }





 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _snwscanf_l(
            wchar_t const* const _Buffer,
                                       size_t         const _BufferCount,
      wchar_t const* const _Format,
                                   _locale_t      const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

    #pragma warning(push)
    #pragma warning(disable: 4996) 
    _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    #pragma warning(pop)

    ((void)(_ArgList = (va_list)0));
    return _Result;
}



 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _snwscanf(
      wchar_t const* const _Buffer,
                                 size_t         const _BufferCount,
          wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

    #pragma warning(push)
    #pragma warning(disable: 4996) 
    _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    #pragma warning(pop)

    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _snwscanf_s_l(
              wchar_t const* const _Buffer,
                                         size_t         const _BufferCount,
      wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
    _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}




__inline int __cdecl _snwscanf_s(
       wchar_t const* const _Buffer,
                                  size_t         const _BufferCount,
         wchar_t const* const _Format,
    ...)



{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
    _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}








} __pragma(pack(pop))
#line 21 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_wstring.h"








#pragma once






__pragma(pack(push, 8)) extern "C" {










    
     errno_t __cdecl wcscat_s(
         wchar_t* _Destination,
         rsize_t _SizeInWords,
         wchar_t const* _Source
        );

    
     errno_t __cdecl wcscpy_s(
         wchar_t* _Destination,
         rsize_t _SizeInWords,
         wchar_t const* _Source
        );
    
    
     errno_t __cdecl wcsncat_s(
         wchar_t*       _Destination,
                                    rsize_t        _SizeInWords,
              wchar_t const* _Source,
                                    rsize_t        _MaxCount
        );
    
    
     errno_t __cdecl wcsncpy_s(
         wchar_t*       _Destination,
                                 rsize_t        _SizeInWords,
           wchar_t const* _Source,
                                 rsize_t        _MaxCount
        );
    
    
     wchar_t* __cdecl wcstok_s(
                         wchar_t*       _String,
                                wchar_t const* _Delimiter,
          wchar_t**      _Context
        );
















  wchar_t* __cdecl _wcsdup(
     wchar_t const* _String
    );











extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source) throw() { return wcscat_s(_Destination, _Size, _Source); } }



    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) wchar_t* __cdecl wcscat( wchar_t *_Destination, wchar_t const* _Source);








 int __cdecl wcscmp(
     wchar_t const* _String1,
     wchar_t const* _String2
    );





extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source) throw() { return wcscpy_s(_Destination, _Size, _Source); } }





__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) wchar_t* __cdecl wcscpy( wchar_t *_Destination, wchar_t const* _Source);


 size_t __cdecl wcscspn(
     wchar_t const* _String,
     wchar_t const* _Control
    );


 size_t __cdecl wcslen(
     wchar_t const* _String
    );










 size_t __cdecl wcsnlen(
     wchar_t const* _Source,
                           size_t         _MaxCount
    );



    
    



    



    static __inline size_t __cdecl wcsnlen_s(
         wchar_t const* _Source,
                               size_t         _MaxCount
        )
    {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }








extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source, size_t _Count) throw() { return wcsncat_s(_Destination, _Size, _Source, _Count); } }







__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) wchar_t* __cdecl wcsncat( wchar_t *_Destination, wchar_t const* _Source, size_t _Count);


 int __cdecl wcsncmp(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount
    );






extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source, size_t _Count) throw() { return wcsncpy_s(_Destination, _Size, _Source, _Count); } }







__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) wchar_t* __cdecl wcsncpy( wchar_t *_Destination, wchar_t const* _Source, size_t _Count);


 wchar_t const* __cdecl wcspbrk(
     wchar_t const* _String,
     wchar_t const* _Control
    );


 size_t __cdecl wcsspn(
     wchar_t const* _String,
     wchar_t const* _Control
    );

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 wchar_t* __cdecl wcstok(
                         wchar_t*       _String,
                                wchar_t const* _Delimiter,
      wchar_t**      _Context
    );



#line 235 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_wstring.h"

    #pragma warning(push)
    #pragma warning(disable: 4141 4996) 

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    static __inline wchar_t* __cdecl _wcstok(
         wchar_t*       const _String,
                wchar_t const* const _Delimiter
        )
    {
        return wcstok(_String, _Delimiter, 0);
    }






        extern "C++"  __declspec(deprecated("wcstok has been changed to conform with the ISO C standard, " "adding an extra context parameter. To use the legacy Microsoft " "wcstok, define _CRT_NON_CONFORMING_WCSTOK.")) 
        inline wchar_t* __cdecl wcstok(
             wchar_t*       _String,
                    wchar_t const* _Delimiter
            ) throw()
        {
            return wcstok(_String, _Delimiter, 0);
        }


    #pragma warning(pop)






 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 wchar_t* __cdecl _wcserror(
     int _ErrorNumber
    );


 errno_t __cdecl _wcserror_s(
     wchar_t* _Buffer,
                                 size_t   _SizeInWords,
                                 int      _ErrorNumber
    );





extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size], int _Error) throw() { return _wcserror_s(_Buffer, _Size, _Error); } }



 __declspec(deprecated("This function or variable may be unsafe. Consider using " "__wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 wchar_t* __cdecl __wcserror(
     wchar_t const* _String
    );

  errno_t __cdecl __wcserror_s(
     wchar_t*       _Buffer,
                                 size_t         _SizeInWords,
                               wchar_t const* _ErrorMessage
    );





extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size], wchar_t const* _ErrorMessage) throw() { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }

  int __cdecl _wcsicmp(
     wchar_t const* _String1,
     wchar_t const* _String2
    );

  int __cdecl _wcsicmp_l(
       wchar_t const* _String1,
       wchar_t const* _String2,
     _locale_t      _Locale
    );

  int __cdecl _wcsnicmp(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount
    );

  int __cdecl _wcsnicmp_l(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount,
                       _locale_t      _Locale
    );

  errno_t __cdecl _wcsnset_s(
     wchar_t* _Destination,
                                size_t   _SizeInWords,
                                wchar_t  _Value,
                                size_t   _MaxCount
    );






extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s(wchar_t (&_Destination)[_Size], wchar_t _Value, size_t _MaxCount) throw() { return _wcsnset_s(_Destination, _Size, _Value, _MaxCount); } }







__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) wchar_t* __cdecl _wcsnset( wchar_t *_String, wchar_t _Value, size_t _MaxCount);

 wchar_t* __cdecl _wcsrev(
     wchar_t* _String
    );

  errno_t __cdecl _wcsset_s(
     wchar_t* _Destination,
                                size_t   _SizeInWords,
                                wchar_t  _Value
    );





extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s(wchar_t (&_String)[_Size], wchar_t _Value) throw() { return _wcsset_s(_String, _Size, _Value); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) wchar_t* __cdecl _wcsset( wchar_t *_String, wchar_t _Value);

  errno_t __cdecl _wcslwr_s(
     wchar_t* _String,
                                size_t   _SizeInWords
    );




extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s(wchar_t (&_String)[_Size]) throw() { return _wcslwr_s(_String, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) wchar_t* __cdecl _wcslwr( wchar_t *_String);


 errno_t __cdecl _wcslwr_s_l(
     wchar_t*  _String,
                                size_t    _SizeInWords,
                            _locale_t _Locale
    );





extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(wchar_t (&_String)[_Size], _locale_t _Locale) throw() { return _wcslwr_s_l(_String, _Size, _Locale); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) wchar_t* __cdecl _wcslwr_l( wchar_t *_String, _locale_t _Locale);


 errno_t __cdecl _wcsupr_s(
     wchar_t* _String,
                         size_t   _Size
    );




extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s(wchar_t (&_String)[_Size]) throw() { return _wcsupr_s(_String, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) wchar_t* __cdecl _wcsupr( wchar_t *_String);


 errno_t __cdecl _wcsupr_s_l(
     wchar_t*  _String,
                         size_t    _Size,
                     _locale_t _Locale
    );





extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(wchar_t (&_String)[_Size], _locale_t _Locale) throw() { return _wcsupr_s_l(_String, _Size, _Locale); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) wchar_t* __cdecl _wcsupr_l( wchar_t *_String, _locale_t _Locale);



 size_t __cdecl wcsxfrm(
      wchar_t*       _Destination,
                                        wchar_t const* _Source,
              size_t         _MaxCount
    );



 size_t __cdecl _wcsxfrm_l(
      wchar_t*       _Destination,
                                        wchar_t const* _Source,
              size_t         _MaxCount,
                                      _locale_t      _Locale
    );


 int __cdecl wcscoll(
     wchar_t const* _String1,
     wchar_t const* _String2
    );


 int __cdecl _wcscoll_l(
       wchar_t const* _String1,
       wchar_t const* _String2,
     _locale_t      _Locale
    );


 int __cdecl _wcsicoll(
     wchar_t const* _String1,
     wchar_t const* _String2
    );


 int __cdecl _wcsicoll_l(
       wchar_t const* _String1,
       wchar_t const* _String2,
     _locale_t      _Locale
    );


 int __cdecl _wcsncoll(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount
    );


 int __cdecl _wcsncoll_l(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount,
                       _locale_t      _Locale
    );


 int __cdecl _wcsnicoll(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount
    );


 int __cdecl _wcsnicoll_l(
     wchar_t const* _String1,
     wchar_t const* _String2,
                           size_t         _MaxCount,
                       _locale_t      _Locale
    );









extern "C++" {

    
    
    inline wchar_t* __cdecl wcschr( wchar_t* _String, wchar_t _C)
    {
        return const_cast<wchar_t*>(wcschr(static_cast<wchar_t const*>(_String), _C));
    }

    
    inline wchar_t* __cdecl wcspbrk( wchar_t* _String,  wchar_t const* _Control)
    {
        return const_cast<wchar_t*>(wcspbrk(static_cast<wchar_t const*>(_String), _Control));
    }

    
    inline wchar_t* __cdecl wcsrchr( wchar_t* _String,  wchar_t _C)
    {
        return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));
    }

     
    
    inline wchar_t* __cdecl wcsstr( wchar_t* _String,  wchar_t const*_SubStr)
    {
        return const_cast<wchar_t*>(wcsstr(static_cast<wchar_t const*>(_String), _SubStr));
    }

}















     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsdup" ". See online help for details."))
     wchar_t* __cdecl wcsdup(
         wchar_t const* _String
        );





    


     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicmp" ". See online help for details."))
     int __cdecl wcsicmp(
         wchar_t const* _String1,
         wchar_t const* _String2
        );
    
     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnicmp" ". See online help for details."))
     int __cdecl wcsnicmp(
         wchar_t const* _String1,
         wchar_t const* _String2,
                               size_t         _MaxCount
        );
    
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnset" ". See online help for details."))
    
     wchar_t* __cdecl wcsnset(
         wchar_t* _String,
                                 wchar_t  _Value,
                                 size_t   _MaxCount
        );
    
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsrev" ". See online help for details."))
    
     wchar_t* __cdecl wcsrev(
         wchar_t* _String
        );
    
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsset" ". See online help for details."))
    
     wchar_t* __cdecl wcsset(
         wchar_t* _String,
              wchar_t  _Value
        );
    
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcslwr" ". See online help for details."))
    
     wchar_t* __cdecl wcslwr(
         wchar_t* _String
        );
    
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsupr" ". See online help for details."))
    
     wchar_t* __cdecl wcsupr(
         wchar_t* _String
        );
    
     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicoll" ". See online help for details."))
     int __cdecl wcsicoll(
         wchar_t const* _String1,
         wchar_t const* _String2
        );





} __pragma(pack(pop))

#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_wtime.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {








struct tm
{
    int tm_sec;   
    int tm_min;   
    int tm_hour;  
    int tm_mday;  
    int tm_mon;   
    int tm_year;  
    int tm_wday;  
    int tm_yday;  
    int tm_isdst; 
};







 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wasctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))


 wchar_t* __cdecl _wasctime(
     struct tm const* _Tm
    );



 errno_t __cdecl _wasctime_s(
      wchar_t*         _Buffer,
                                         size_t           _SizeInWords,
                                                      struct tm const* _Tm
    );






extern "C++" { template <size_t _Size> inline errno_t __cdecl _wasctime_s(wchar_t (&_Buffer)[_Size], struct tm const* _Time) throw() { return _wasctime_s(_Buffer, _Size, _Time); } }



 size_t __cdecl wcsftime(
      wchar_t*         _Buffer,
                              size_t           _SizeInWords,
                            wchar_t const*   _Format,
                              struct tm const* _Tm
    );



 size_t __cdecl _wcsftime_l(
      wchar_t*         _Buffer,
                              size_t           _SizeInWords,
                            wchar_t const*   _Format,
                              struct tm const* _Tm,
                          _locale_t        _Locale
    );


 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 wchar_t* __cdecl _wctime32(
     __time32_t const* _Time
    );


 errno_t __cdecl _wctime32_s(
      wchar_t*          _Buffer,
                                    size_t            _SizeInWords,
                                                      __time32_t const* _Time
    );





extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime32_s(wchar_t (&_Buffer)[_Size], __time32_t const* _Time) throw() { return _wctime32_s(_Buffer, _Size, _Time); } }



 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 wchar_t* __cdecl _wctime64(
     __time64_t const* _Time
    );


 errno_t __cdecl _wctime64_s(
      wchar_t*          _Buffer,
                                    size_t            _SizeInWords,
                                                      __time64_t const* _Time);





extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime64_s(wchar_t (&_Buffer)[_Size], __time64_t const* _Time) throw() { return _wctime64_s(_Buffer, _Size, _Time); } }


 errno_t __cdecl _wstrdate_s(
      wchar_t* _Buffer,
                                    size_t   _SizeInWords
    );




extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrdate_s(wchar_t (&_Buffer)[_Size]) throw() { return _wstrdate_s(_Buffer, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) wchar_t* __cdecl _wstrdate( wchar_t *_Buffer);


 errno_t __cdecl _wstrtime_s(
      wchar_t* _Buffer,
                                    size_t   _SizeInWords
    );




extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrtime_s(wchar_t (&_Buffer)[_Size]) throw() { return _wstrtime_s(_Buffer, _Size); } }




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) wchar_t* __cdecl _wstrtime( wchar_t *_Buffer);









    #pragma warning(push)
    #pragma warning(disable: 4996)

#line 183 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\corecrt_wtime.h"

        
        static __inline wchar_t * __cdecl _wctime(
             time_t const* const _Time)
        {
            return _wctime64(_Time);
        }

        
        static __inline errno_t __cdecl _wctime_s(
               wchar_t*      const _Buffer,
                                                            size_t        const _SizeInWords,
                                                            time_t const* const _Time
            )
        {
            return _wctime64_s(_Buffer, _SizeInWords, _Time);
        }



    #pragma warning(pop)




} __pragma(pack(pop))
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\sys/stat.h"







#pragma once

#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\sys/types.h"







#pragma once






    typedef unsigned short _ino_t; 


        typedef _ino_t ino_t;








    typedef unsigned int _dev_t; 


        typedef _dev_t dev_t;








    typedef long _off_t; 


        typedef _off_t off_t;
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\sys/stat.h"

__pragma(pack(push, 8)) extern "C" {



#pragma warning(push)
#pragma warning(disable:4820)  








struct _stat32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat32i64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat64i32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};

struct _stat64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};




    struct stat
    {
        _dev_t         st_dev;
        _ino_t         st_ino;
        unsigned short st_mode;
        short          st_nlink;
        short          st_uid;
        short          st_gid;
        _dev_t         st_rdev;
        _off_t         st_size;
        time_t         st_atime;
        time_t         st_mtime;
        time_t         st_ctime;
    };









#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\sys/stat.h"

#line 131 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\sys/stat.h"








#line 154 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\sys/stat.h"



 int __cdecl _fstat32(
      int             _FileHandle,
     struct _stat32* _Stat
    );

 int __cdecl _fstat32i64(
      int                _FileHandle,
     struct _stat32i64* _Stat
    );

 int __cdecl _fstat64i32(
      int                _FileHandle,
     struct _stat64i32* _Stat
    );

 int __cdecl _fstat64(
      int             _FileHandle,
     struct _stat64* _Stat
    );

 int __cdecl _stat32(
     char const*     _FileName,
      struct _stat32* _Stat
    );

 int __cdecl _stat32i64(
     char const*        _FileName,
      struct _stat32i64* _Stat
    );

 int __cdecl _stat64i32(
     char const*        _FileName,
      struct _stat64i32* _Stat
    );

 int __cdecl _stat64(
     char const*     _FileName,
      struct _stat64* _Stat
    );

 int __cdecl _wstat32(
     wchar_t const*  _FileName,
      struct _stat32* _Stat
    );

 int __cdecl _wstat32i64(
     wchar_t const*     _FileName,
      struct _stat32i64* _Stat
    );

 int __cdecl _wstat64i32(
     wchar_t const*     _FileName,
      struct _stat64i32* _Stat
    );

 int __cdecl _wstat64(
     wchar_t const*  _FileName,
      struct _stat64* _Stat
    );



#line 235 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\sys/stat.h"

        static __inline int __cdecl fstat(int const _FileHandle, struct stat* const _Stat)
        {
            typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
            return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);
        }
        static __inline int __cdecl stat(char const* const _FileName, struct stat* const _Stat)
        {
            typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
            return _stat64i32(_FileName, (struct _stat64i32*)_Stat);
        }






#pragma warning(pop)



} __pragma(pack(pop))
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.10586.0\\ucrt\\wchar.h"



__pragma(pack(push, 8)) extern "C" {








typedef wchar_t _Wint_t;




 wchar_t* __cdecl _wsetlocale(
           int            _Category,
     wchar_t const* _Locale
    );


 _locale_t __cdecl _wcreate_locale(
       int            _Category,
     wchar_t const* _Locale
    );



 wint_t __cdecl btowc(
     int _Ch
    );

 size_t __cdecl mbrlen(
      char const* _Ch,
                                               size_t      _SizeInBytes,
                                            mbstate_t*  _State
    );

 size_t __cdecl mbrtowc(
                            wchar_t*    _DstCh,
      char const* _SrcCh,
                                               size_t      _SizeInBytes,
                                            mbstate_t*  _State
    );


 errno_t __cdecl mbsrtowcs_s(
                             size_t*      _Retval,
             wchar_t*     _Dst,
                                  size_t       _Size,
                     char const** _PSrc,
                                  size_t       _N,
                               mbstate_t*   _State
    );









extern "C++" { template <size_t _Size> inline errno_t __cdecl mbsrtowcs_s(size_t* _Retval, wchar_t (&_Dest)[_Size], char const** _PSource, size_t _Count, mbstate_t* _State) throw() { return mbsrtowcs_s(_Retval, _Dest, _Size, _PSource, _Count, _State); } }







__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbsrtowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) size_t __cdecl mbsrtowcs( wchar_t *_Dest, char const** _PSrc, size_t _Count, mbstate_t* _State);


 errno_t __cdecl wcrtomb_s(
                            size_t*    _Retval,
     char*      _Dst,
                                 size_t     _SizeInBytes,
                                 wchar_t    _Ch,
                          mbstate_t* _State
    );








extern "C++" { template <size_t _Size> inline errno_t __cdecl wcrtomb_s(size_t* _Retval, char (&_Dest)[_Size], wchar_t _Source, mbstate_t* _State) throw() { return wcrtomb_s(_Retval, _Dest, _Size, _Source, _State); } }






__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcrtomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) size_t __cdecl wcrtomb( char *_Dest, wchar_t _Source, mbstate_t* _State);


 errno_t __cdecl wcsrtombs_s(
                                             size_t*         _Retval,
     char*           _Dst,
                                                  size_t          _SizeInBytes,
                              wchar_t const** _Src,
                                                  size_t          _Size,
                                           mbstate_t*      _State
    );









extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsrtombs_s(size_t* _Retval, char (&_Dest)[_Size], wchar_t const** _PSrc, size_t _Count, mbstate_t* _State) throw() { return wcsrtombs_s(_Retval, _Dest, _Size, _PSrc, _Count, _State); } }







__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsrtombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) size_t __cdecl wcsrtombs( char *_Dest, wchar_t const** _PSource, size_t _Count, mbstate_t* _State);

 int __cdecl wctob(
     wint_t _WCh
    );







        
        errno_t __cdecl wmemcpy_s(
             wchar_t*       _S1,
                                     rsize_t        _N1,
                       wchar_t const* _S2,
                                     rsize_t        _N
            );

        
        errno_t __cdecl wmemmove_s(
             wchar_t*       _S1,
                                     rsize_t        _N1,
                       wchar_t const* _S2,
                                     rsize_t        _N
            );



    __inline int __cdecl fwide(
         FILE* _F,
             int   _M
        )
    {
        (void)_F;
        return (_M);
    }

    __inline int __cdecl mbsinit(
         mbstate_t const* _P
        )
    {
        return _P == 0 || _P->_Wchar == 0;
    }

    __inline wchar_t const* __cdecl wmemchr(
         wchar_t const* _S,
                   wchar_t        _C,
                   size_t         _N
        )
    {
        for (; 0 < _N; ++_S, --_N)
            if (*_S == _C)
                return (wchar_t const*)_S;

        return 0;
    }

    __inline int __cdecl wmemcmp(
         wchar_t const* _S1,
         wchar_t const* _S2,
                   size_t         _N
        )
    {
        for (; 0 < _N; ++_S1, ++_S2, --_N)
            if (*_S1 != *_S2)
                return *_S1 < *_S2 ? -1 : 1;

        return 0;
    }

    
    
    __inline 
    wchar_t* __cdecl wmemcpy(
         wchar_t*       _S1,
               wchar_t const* _S2,
                         size_t         _N
        )
    {
        #pragma warning(push)
        #pragma warning(disable : 4995 4996 6386)
        return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));
        #pragma warning(pop)
    }

    __inline 
    wchar_t* __cdecl wmemmove(
         wchar_t*       _S1,
               wchar_t const* _S2,
                             size_t         _N
        )
    {
        #pragma warning(push)
        #pragma warning(disable : 4996 6386)
        return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));
        #pragma warning(pop)
    }

    
    
    __inline wchar_t* __cdecl wmemset(
         wchar_t* _S,
                         wchar_t  _C,
                         size_t   _N
        )
    {
        wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
        {
            *_Su = _C;
        }
        return _S;
    }



        extern "C++" inline wchar_t* __cdecl wmemchr(
             wchar_t* _S,
                       wchar_t  _C,
                       size_t   _N
            )
        {
            wchar_t const* const _SC = _S;
            return const_cast<wchar_t*>(wmemchr(_SC, _C, _N));
        }







} __pragma(pack(pop))
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\cwchar"


typedef mbstate_t _Mbstatet;


namespace std {
using :: _Mbstatet;

using :: mbstate_t; using :: size_t; using :: tm; using :: wint_t;

using :: btowc; using :: fgetwc; using :: fgetws; using :: fputwc;
using :: fputws; using :: fwide; using :: fwprintf;
using :: fwscanf; using :: getwc; using :: getwchar;
using :: mbrlen; using :: mbrtowc; using :: mbsrtowcs;
using :: mbsinit; using :: putwc; using :: putwchar;
using :: swprintf; using :: swscanf; using :: ungetwc;
using :: vfwprintf; using :: vswprintf; using :: vwprintf;
using :: wcrtomb; using :: wprintf; using :: wscanf;
using :: wcsrtombs; using :: wcstol; using :: wcscat;
using :: wcschr; using :: wcscmp; using :: wcscoll;
using :: wcscpy; using :: wcscspn; using :: wcslen;
using :: wcsncat; using :: wcsncmp; using :: wcsncpy;
using :: wcspbrk; using :: wcsrchr; using :: wcsspn;
using :: wcstod; using :: wcstoul; using :: wcsstr;
using :: wcstok; using :: wcsxfrm; using :: wctob;
using :: wmemchr; using :: wmemcmp; using :: wmemcpy;
using :: wmemmove; using :: wmemset; using :: wcsftime;

using :: vfwscanf; using :: vswscanf; using :: vwscanf;
using :: wcstof; using :: wcstold;
using :: wcstoll; using :: wcstoull;
}







 
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\limits"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xstddef"

#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\cstddef"

#pragma once




#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\cstddef"


namespace std {
using :: ptrdiff_t; using :: size_t;
}



namespace std {
typedef double max_align_t;	
}






 
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xstddef"


#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\initializer_list"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)



namespace std {
		
template<class _Elem>
	class initializer_list
	{	
public:
	typedef _Elem value_type;
	typedef const _Elem& reference;
	typedef const _Elem& const_reference;
	typedef size_t size_type;

	typedef const _Elem* iterator;
	typedef const _Elem* const_iterator;

	constexpr initializer_list() noexcept
		: _First(0), _Last(0)
		{	
		}

	constexpr initializer_list(const _Elem *_First_arg,
		const _Elem *_Last_arg) noexcept
		: _First(_First_arg), _Last(_Last_arg)
		{	
		}

	constexpr const _Elem *begin() const noexcept
		{	
		return (_First);
		}

	constexpr const _Elem *end() const noexcept
		{	
		return (_Last);
		}

	constexpr size_t size() const noexcept
		{	
		return ((size_t)(_Last - _First));
		}

private:
	const _Elem *_First;
	const _Elem *_Last;
	};

		
template<class _Elem> inline
	constexpr const _Elem *begin(initializer_list<_Elem> _Ilist) noexcept
	{	
	return (_Ilist.begin());
	}

		
template<class _Elem> inline
	constexpr const _Elem *end(initializer_list<_Elem> _Ilist) noexcept
	{	
	return (_Ilist.end());
	}
}

 #pragma warning(pop)
 #pragma pack(pop)






 
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xstddef"



 #pragma pack(push,8)
 #pragma warning(push,3)









namespace std {
		















#line 58 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xstddef"

#line 81 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xstddef"

		


		


#line 123 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xstddef"




		

template<bool,
	class _Ty1,
	class _Ty2>
	struct _If
	{	
	typedef _Ty2 type;
	};

template<class _Ty1,
	class _Ty2>
	struct _If<true, _Ty1, _Ty2>
	{	
	typedef _Ty1 type;
	};

template<class _Ty>
	struct _Always_false
	{	
	static const bool value = false;
	};

		


		
template<class _Arg,
	class _Result>
	struct unary_function
	{	
	typedef _Arg argument_type;
	typedef _Result result_type;
	};

		
template<class _Arg1,
	class _Arg2,
	class _Result>
	struct binary_function
	{	
	typedef _Arg1 first_argument_type;
	typedef _Arg2 second_argument_type;
	typedef _Result result_type;
	};


		
template<class _Ty = void>
	struct plus
	{	
	typedef _Ty first_argument_type;
	typedef _Ty second_argument_type;
	typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left + _Right);
		}
	};

		
template<class _Ty = void>
	struct minus
	{	
	typedef _Ty first_argument_type;
	typedef _Ty second_argument_type;
	typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left - _Right);
		}
	};

		
template<class _Ty = void>
	struct multiplies
	{	
	typedef _Ty first_argument_type;
	typedef _Ty second_argument_type;
	typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left * _Right);
		}
	};

		
template<class _Ty = void>
	struct equal_to
	{	
	typedef _Ty first_argument_type;
	typedef _Ty second_argument_type;
	typedef bool result_type;

	constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left == _Right);
		}
	};

		
template<class _Ty = void>
	struct less
	{	
	typedef _Ty first_argument_type;
	typedef _Ty second_argument_type;
	typedef bool result_type;

	constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left < _Right);
		}
	};

		
template<>
	struct plus<void>
	{	
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			+ static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			+ static_cast<_Ty2&&>(_Right));
		}
	};

		
template<>
	struct minus<void>
	{	
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			- static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			- static_cast<_Ty2&&>(_Right));
		}
	};

		
template<>
	struct multiplies<void>
	{	
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			* static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			* static_cast<_Ty2&&>(_Right));
		}
	};

		
template<>
	struct equal_to<void>
	{	
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			== static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			== static_cast<_Ty2&&>(_Right));
		}
	};

		
template<>
	struct less<void>
	{	
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			< static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			< static_cast<_Ty2&&>(_Right));
		}
	};


}



namespace std {
	
inline size_t _Hash_seq(const unsigned char *_First, size_t _Count)
	{	

	static_assert(sizeof(size_t) == 8, "This code is for 64-bit size_t.");
	const size_t _FNV_offset_basis = 14695981039346656037ULL;
	const size_t _FNV_prime = 1099511628211ULL;







	size_t _Val = _FNV_offset_basis;
	for (size_t _Next = 0; _Next < _Count; ++_Next)
		{	
		_Val ^= (size_t)_First[_Next];
		_Val *= _FNV_prime;
		}
	return (_Val);
	}

	
template<class _Kty>
	struct _Bitwise_hash
	{	
	typedef _Kty argument_type;
	typedef size_t result_type;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Hash_seq((const unsigned char *)&_Keyval, sizeof (_Kty)));
		}
	};

	
template<class _Kty>
	struct hash
		: public _Bitwise_hash<_Kty>
	{	
	static const bool _Value = __is_enum(_Kty);
	static_assert(_Value,
		"The C++ Standard doesn't provide a hash for this type.");
	};
template<>
	struct hash<bool>
		: public _Bitwise_hash<bool>
	{	
	};

template<>
	struct hash<char>
		: public _Bitwise_hash<char>
	{	
	};

template<>
	struct hash<signed char>
		: public _Bitwise_hash<signed char>
	{	
	};

template<>
	struct hash<unsigned char>
		: public _Bitwise_hash<unsigned char>
	{	
	};

template<>
	struct hash<char16_t>
		: public _Bitwise_hash<char16_t>
	{	
	};

template<>
	struct hash<char32_t>
		: public _Bitwise_hash<char32_t>
	{	
	};


template<>
	struct hash<wchar_t>
		: public _Bitwise_hash<wchar_t>
	{	
	};


template<>
	struct hash<short>
		: public _Bitwise_hash<short>
	{	
	};

template<>
	struct hash<unsigned short>
		: public _Bitwise_hash<unsigned short>
	{	
	};

template<>
	struct hash<int>
		: public _Bitwise_hash<int>
	{	
	};

template<>
	struct hash<unsigned int>
		: public _Bitwise_hash<unsigned int>
	{	
	};

template<>
	struct hash<long>
		: public _Bitwise_hash<long>
	{	
	};

template<>
	struct hash<unsigned long>
		: public _Bitwise_hash<unsigned long>
	{	
	};

template<>
	struct hash<long long>
		: public _Bitwise_hash<long long>
	{	
	};

template<>
	struct hash<unsigned long long>
		: public _Bitwise_hash<unsigned long long>
	{	
	};

template<>
	struct hash<float>
		: public _Bitwise_hash<float>
	{	
	typedef float _Kty;
	typedef _Bitwise_hash<_Kty> _Mybase;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Mybase::operator()(
			_Keyval == 0 ? 0 : _Keyval));	
		}
	};

template<>
	struct hash<double>
		: public _Bitwise_hash<double>
	{	
	typedef double _Kty;
	typedef _Bitwise_hash<_Kty> _Mybase;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Mybase::operator()(
			_Keyval == 0 ? 0 : _Keyval));	
		}
	};

template<>
	struct hash<long double>
		: public _Bitwise_hash<long double>
	{	
	typedef long double _Kty;
	typedef _Bitwise_hash<_Kty> _Mybase;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Mybase::operator()(
			_Keyval == 0 ? 0 : _Keyval));	
		}
	};

template<class _Ty>
	struct hash<_Ty *>
		: public _Bitwise_hash<_Ty *>
	{	
	};
}


namespace std {
namespace tr1 {	
using ::std:: hash;
}	
}




#line 538 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xstddef"

#line 546 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xstddef"

#line 557 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xstddef"













#line 576 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xstddef"

#line 584 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xstddef"






















#line 619 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xstddef"





namespace std {
	
template<class... _Types>
	struct _Arg_types
	{	
	};

template<class _Ty1>
	struct _Arg_types<_Ty1>
	{	
	typedef _Ty1 argument_type;
	};

template<class _Ty1,
	class _Ty2>
	struct _Arg_types<_Ty1, _Ty2>
	{	
	typedef _Ty1 first_argument_type;
	typedef _Ty2 second_argument_type;
	};

	
template<class _Ty>
	struct _Is_function
	{	
	typedef false_type _Bool_type;
	};

#line 661 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\xstddef"

template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...)> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...)> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; };


template<class _Ret,
	class... _Types>
	struct _Is_function<_Ret (_Types..., ...)>
	{	
	typedef true_type _Bool_type;
	typedef _Ret result_type;
	};

template<class _Ty>
	struct is_function
		: _Is_function<_Ty>::_Bool_type
	{	
	};

		
template<class _Ty> inline
	_Ty *_Addressof(_Ty& _Val, true_type) noexcept
	{	
	return (_Val);
	}

template<class _Ty> inline
	_Ty *_Addressof(_Ty& _Val, false_type) noexcept
	{	
	return (reinterpret_cast<_Ty *>(
		&const_cast<char&>(
		reinterpret_cast<const volatile char&>(_Val))));
	}

template<class _Ty> inline
	_Ty *addressof(_Ty& _Val) noexcept
	{	
	return (_Addressof(_Val, is_function<_Ty>()));
	}
}

 #pragma warning(pop)
 #pragma pack(pop)






 
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\limits"

 #pragma pack(push,8)
 #pragma warning(push,3)



namespace std {
































		
typedef enum
	{	
	denorm_indeterminate = -1,
	denorm_absent = 0,
	denorm_present = 1}
		float_denorm_style;

		
typedef enum
	{	
	round_indeterminate = -1,
	round_toward_zero = 0,
	round_to_nearest = 1,
	round_toward_infinity = 2,
	round_toward_neg_infinity = 3}
		float_round_style;

		
struct _Num_base
	{	
	static constexpr float_denorm_style has_denorm = (float_denorm_style)(denorm_absent);
	static constexpr bool has_denorm_loss = (bool)(false);
	static constexpr bool has_infinity = (bool)(false);
	static constexpr bool has_quiet_NaN = (bool)(false);
	static constexpr bool has_signaling_NaN = (bool)(false);
	static constexpr bool is_bounded = (bool)(false);
	static constexpr bool is_exact = (bool)(false);
	static constexpr bool is_iec559 = (bool)(false);
	static constexpr bool is_integer = (bool)(false);
	static constexpr bool is_modulo = (bool)(false);
	static constexpr bool is_signed = (bool)(false);
	static constexpr bool is_specialized = (bool)(false);
	static constexpr bool tinyness_before = (bool)(false);
	static constexpr bool traps = (bool)(false);
	static constexpr float_round_style round_style = (float_round_style)(round_toward_zero);
	static constexpr int digits = (int)(0);
	static constexpr int digits10 = (int)(0);

	static constexpr int max_digits10 = (int)(0);

	static constexpr int max_exponent = (int)(0);
	static constexpr int max_exponent10 = (int)(0);
	static constexpr int min_exponent = (int)(0);
	static constexpr int min_exponent10 = (int)(0);
	static constexpr int radix = (int)(0);
	};

		
template<class _Ty>
	class numeric_limits
		: public _Num_base
	{	
public:
	static constexpr _Ty (min)() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty lowest() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (_Ty());
		}
	};

template<class _Ty>
	class numeric_limits<const _Ty>
		: public numeric_limits<_Ty>
	{	
	};

template<class _Ty>
	class numeric_limits<volatile _Ty>
		: public numeric_limits<_Ty>
	{	
	};

template<class _Ty>
	class numeric_limits<const volatile _Ty>
		: public numeric_limits<_Ty>
	{	
	};

		
struct _Num_int_base
	: public _Num_base
	{	
	static constexpr bool is_bounded = (bool)(true);
	static constexpr bool is_exact = (bool)(true);
	static constexpr bool is_integer = (bool)(true);
	static constexpr bool is_modulo = (bool)(true);
	static constexpr bool is_specialized = (bool)(true);
	static constexpr int radix = (int)(2);
	};

		
struct _Num_float_base
	: public _Num_base
	{	
	static constexpr float_denorm_style has_denorm = (float_denorm_style)(denorm_present);
	static constexpr bool has_denorm_loss = (bool)(true);
	static constexpr bool has_infinity = (bool)(true);
	static constexpr bool has_quiet_NaN = (bool)(true);
	static constexpr bool has_signaling_NaN = (bool)(true);
	static constexpr bool is_bounded = (bool)(true);
	static constexpr bool is_exact = (bool)(false);
	static constexpr bool is_iec559 = (bool)(true);
	static constexpr bool is_integer = (bool)(false);
	static constexpr bool is_modulo = (bool)(false);
	static constexpr bool is_signed = (bool)(true);
	static constexpr bool is_specialized = (bool)(true);
	static constexpr bool tinyness_before = (bool)(true);
	static constexpr bool traps = (bool)(false);
	static constexpr float_round_style round_style = (float_round_style)(round_to_nearest);
	static constexpr int radix = (int)(2);
	};

		
template<> class numeric_limits<char>
	: public _Num_int_base
	{	
public:
	typedef char _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((-128));
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (127);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)((-128) != 0);
	static constexpr int digits = (int)(8 - ((-128) != 0 ? 1 : 0));
	static constexpr int digits10 = (int)((8 - ((-128) != 0 ? 1 : 0)) * 301L / 1000);

	};

		
template<> class numeric_limits<wchar_t>
	: public _Num_int_base
	{	
public:
	typedef wchar_t _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((_Ty)0x0000);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return ((_Ty)0xffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(0x0000 != 0);
	static constexpr int digits = (int)(8 * sizeof (wchar_t) - (0x0000 != 0 ? 1 : 0));

	static constexpr int digits10 = (int)((8 * sizeof (wchar_t) - (0x0000 != 0 ? 1 : 0)) * 301L / 1000);

	};

		
template<> class numeric_limits<bool>
	: public _Num_int_base
	{	
public:
	typedef bool _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (false);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (true);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_modulo = (bool)(false);
	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(1);
	static constexpr int digits10 = (int)(0);
	};

		
template<> class numeric_limits<signed char>
	: public _Num_int_base
	{	
public:
	typedef signed char _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((-128));
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (127);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(true);
	static constexpr int digits = (int)(8 - 1);
	static constexpr int digits10 = (int)((8 - 1) * 301L / 1000);
	};

		
template<> class numeric_limits<unsigned char>
	: public _Num_int_base
	{	
public:
	typedef unsigned char _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8);
	static constexpr int digits10 = (int)(8 * 301L / 1000);
	};

		
template<> class numeric_limits<short>
	: public _Num_int_base
	{	
public:
	typedef short _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((-32768));
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (32767);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(true);
	static constexpr int digits = (int)(8 * sizeof (short) - 1);
	static constexpr int digits10 = (int)((8 * sizeof (short) - 1) * 301L / 1000);

	};


		
template<> class numeric_limits<unsigned short>
	: public _Num_int_base
	{	
public:
	typedef unsigned short _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (unsigned short));
	static constexpr int digits10 = (int)(8 * sizeof (unsigned short) * 301L / 1000);

	};


		
template<> class numeric_limits<char16_t>
	: public _Num_int_base
	{	
public:
	typedef char16_t _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (char16_t));
	static constexpr int digits10 = (int)(8 * sizeof (char16_t) * 301L / 1000);

	};

		
template<> class numeric_limits<int>
	: public _Num_int_base
	{	
public:
	typedef int _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((-2147483647 - 1));
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (2147483647);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(true);
	static constexpr int digits = (int)(8 * sizeof (int) - 1);
	static constexpr int digits10 = (int)((8 * sizeof (int) - 1) * 301L / 1000);

	};

		
template<> class numeric_limits<unsigned int>
	: public _Num_int_base
	{	
public:
	typedef unsigned int _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffffffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (unsigned int));
	static constexpr int digits10 = (int)(8 * sizeof (unsigned int) * 301L / 1000);

	};

		
template<> class numeric_limits<long>
	: public _Num_int_base
	{	
public:
	typedef long _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((-2147483647L - 1));
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (2147483647L);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(true);
	static constexpr int digits = (int)(8 * sizeof (long) - 1);
	static constexpr int digits10 = (int)((8 * sizeof (long) - 1) * 301L / 1000);

	};

		
template<> class numeric_limits<unsigned long>
	: public _Num_int_base
	{	
public:
	typedef unsigned long _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffffffffUL);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (unsigned long));
	static constexpr int digits10 = (int)(8 * sizeof (unsigned long) * 301L / 1000);

	};

		
template<> class numeric_limits<char32_t>
	: public _Num_int_base
	{	
public:
	typedef char32_t _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffffffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (char32_t));
	static constexpr int digits10 = (int)(8 * sizeof (char32_t) * 301L / 1000);

	};


		
template<> class numeric_limits<long long>
	: public _Num_int_base
	{	
public:
	typedef long long _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (-0x7fffffffffffffff - 1);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0x7fffffffffffffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(true);
	static constexpr int digits = (int)(8 * sizeof (long long) - 1);
	static constexpr int digits10 = (int)((8 * sizeof (long long) - 1) * 301L / 1000);

	};

		
template<> class numeric_limits<unsigned long long>
	: public _Num_int_base
	{	
public:
	typedef unsigned long long _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffffffffffffffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (unsigned long long));
	static constexpr int digits10 = (int)(8 * sizeof (unsigned long long) * 301L / 1000);

	};


		
template<> class numeric_limits<float>
	: public _Num_float_base
	{	
public:
	typedef float _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (1.17549435e-38F);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (3.402823466e+38F);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return (-(max)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (1.19209290e-07F);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0.5F);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (1.401298464e-45F);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (((float)((float)(1e+300 * 1e+300))));
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (nanf);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (nanf);
		}

	static constexpr int digits = (int)(24);
	static constexpr int digits10 = (int)(6);

	static constexpr int max_digits10 = (int)(2 + 24 * 301L / 1000);

	static constexpr int max_exponent = (int)((int)128);
	static constexpr int max_exponent10 = (int)((int)38);
	static constexpr int min_exponent = (int)((int)(-125));
	static constexpr int min_exponent10 = (int)((int)(-37));
	};

		
template<> class numeric_limits<double>
	: public _Num_float_base
	{	
public:
	typedef double _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (2.2250738585072014e-308);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (1.7976931348623157e+308);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return (-(max)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (2.2204460492503131e-16);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0.5);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (4.9406564584124654e-324);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (((double)((float)(1e+300 * 1e+300))));
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (nan);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (nan);
		}

	static constexpr int digits = (int)(53);
	static constexpr int digits10 = (int)(15);

	static constexpr int max_digits10 = (int)(2 + 53 * 301L / 1000);

	static constexpr int max_exponent = (int)((int)1024);
	static constexpr int max_exponent10 = (int)((int)308);
	static constexpr int min_exponent = (int)((int)(-1021));
	static constexpr int min_exponent10 = (int)((int)(-307));
	};

		
template<> class numeric_limits<long double>
	: public _Num_float_base
	{	
public:
	typedef long double _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (2.2250738585072014e-308L);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (1.7976931348623157e+308L);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return (-(max)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (2.2204460492503131e-16L);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0.5L);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (4.9406564584124654e-324);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (((double)((float)(1e+300 * 1e+300))));
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (nan);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (nan);
		}

	static constexpr int digits = (int)(53);
	static constexpr int digits10 = (int)(15);

	static constexpr int max_digits10 = (int)(2 + 53 * 301L / 1000);

	static constexpr int max_exponent = (int)((int)1024);
	static constexpr int max_exponent10 = (int)((int)308);
	static constexpr int min_exponent = (int)((int)(-1021));
	static constexpr int min_exponent10 = (int)((int)(-307));
	};

#line 1470 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\INCLUDE\\limits"















}

 #pragma warning(pop)
 #pragma pack(pop)






 
#line 2 "limits.cpp"
